<hr>
<p>title: My New Post<br>date: 2020-08-08 22:13:35<br>tags: webpack<br>categories: 打包工具<br>summary: 前端大型项目打包上线必备</p>
<hr>
<h2 id="webpack概述"><a href="#webpack概述" class="headerlink" title="webpack概述"></a>webpack概述</h2><blockquote>
<p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler</em> )</p>
</blockquote>
<p><a href="https://www.webpackjs.com/">webpack中文网</a></p>
<p><a href="https://webpack.js.org/">webpack官网</a></p>
<p>##webpack做了什么</p>
<ul>
<li>语法转换<ul>
<li>less/sass转换成css</li>
<li>ES6转换成ES5</li>
<li>typescript转换成js</li>
</ul>
</li>
<li>html/css/js代码的压缩与合并（打包）</li>
<li>webpack可以在开发期间提供一个开发环境<ul>
<li>自动开启浏览器</li>
<li>自动监视文件变化</li>
<li>自动刷新浏览器</li>
</ul>
</li>
<li>项目一般都需要经过webpack打包之后才上线。</li>
</ul>
<h2 id="webpack模块说明"><a href="#webpack模块说明" class="headerlink" title="webpack模块说明"></a>webpack模块说明</h2><p>webpack会把所有的资源都当成模块</p>
<ul>
<li>css</li>
<li>js</li>
<li>图片</li>
<li>字体图标</li>
</ul>
<p>webpack给前端开发提供了模块化的开发环境</p>
<ul>
<li>对于js文件，webpack中支持AMD、CMD、commonJS、ES6模块化等语法</li>
<li>有了webpack，我们可以在前端代码中使用任意的模块化语法</li>
<li>可以在浏览器中使用nodejs的模块化语法<code>const $ = require(&#39;jquery&#39;)</code></li>
</ul>
<h2 id="webpack基本使用"><a href="#webpack基本使用" class="headerlink" title="webpack基本使用"></a>webpack基本使用</h2><ul>
<li>创建一个文件夹<code>webpack-demo</code></li>
<li>初始化项目 生成<code>package.json</code></li>
</ul>
<pre><code class="bash">yarn init -y</code></pre>
<ul>
<li>安装webpack的依赖包</li>
</ul>
<pre><code class="bash">yarn add webpack webpack-cli -D</code></pre>
<ul>
<li><p>新建文件<code>src</code>和<code>dist</code>文件夹，，src用于提供源码，，dist用于存放打包后的文件</p>
</li>
<li><p>在src下新建了<code>index.js</code>文件，目的：对<code>src/index.js</code>文件进行打包</p>
</li>
<li><p>在package.json文件配置了打包的脚本</p>
</li>
</ul>
<pre><code class="js">  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;
  }</code></pre>
<ul>
<li>在项目的根目录，创建一个文件<code>webpack.config.js</code></li>
<li>执行打包命令</li>
</ul>
<pre><code class="js">yarn build</code></pre>
<h2 id="配置webpack的打包入口"><a href="#配置webpack的打包入口" class="headerlink" title="配置webpack的打包入口"></a>配置webpack的打包入口</h2><ul>
<li>在<code>webpack.config.js</code>文件中</li>
</ul>
<pre><code class="js">// 这是webpack的配置文件 
// webpack是运行在node环境中，webpack可以执行任意的node代码，包括可以使用node中模块。
module.exports = {
  // 默认： ./src/index.js
  entry: &#39;./src/app.js&#39;
}</code></pre>
<h2 id="配置webpack的打包出口"><a href="#配置webpack的打包出口" class="headerlink" title="配置webpack的打包出口"></a>配置webpack的打包出口</h2><blockquote>
<p>配置webpack最终打包的文件的出口</p>
</blockquote>
<pre><code class="js">  // 配置webpack打包出口
  output: {
    // path： 打包出口的目录,默认 dist, 必须指定绝对路径
    path: path.join(__dirname, &#39;lib&#39;),
    // filename: 打包出口的文件名字  默认 main.js
    filename: &#39;bundle.js&#39;
  }</code></pre>
<p>==如果要配置path，记得是绝对路径==</p>
<h2 id="配置webpack的打包模式"><a href="#配置webpack的打包模式" class="headerlink" title="配置webpack的打包模式"></a>配置webpack的打包模式</h2><pre><code class="js">  // 打包模式  development|production
  // development: 打包不会对进行压缩   打包快
  // production: 打包会对代码进行压缩  上线
  mode: &#39;development&#39;</code></pre>
<h2 id="配置html-webpack-plugin插件"><a href="#配置html-webpack-plugin插件" class="headerlink" title="配置html-webpack-plugin插件"></a>配置html-webpack-plugin插件</h2><blockquote>
<p>html-webpack-plugin插件能够帮助我们自动在dist中生成一个html文件，并且会自动帮我们引入打包后的文件。</p>
</blockquote>
<ul>
<li>安装html-webpack-plugin插件</li>
</ul>
<pre><code class="bash">yarn add html-webpack-plugin -D</code></pre>
<ul>
<li>在<code>webpack.config.js</code>中配置</li>
</ul>
<pre><code class="js">//1. 导入html-webpack-plugin插件
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

// 2.配置webpack的插件，是一个数组
plugins: [new HtmlWebpackPlugin({
  // 生成html的模板
  template: &#39;./src/index.html&#39;
})]</code></pre>
<h2 id="配置css-loader处理css文件"><a href="#配置css-loader处理css文件" class="headerlink" title="配置css-loader处理css文件"></a>配置css-loader处理css文件</h2><blockquote>
<p>webpack天生只能处理js文件，如果需要处理其他类型的文件，需要配置loader</p>
</blockquote>
<ul>
<li>安装依赖包</li>
</ul>
<pre><code class="js">yarn add css-loader style-loader -D</code></pre>
<ul>
<li>配置loader</li>
</ul>
<pre><code class="js">
module: {
  rules: [
    // 配置css-loader的规则
    {
      // 匹配所有.css结尾的文件
      test: /\.css$/,
      // 使用css-loader 和 style-loader处理
      use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
    }
  ]
}</code></pre>
<p>==注意：loader加载顺序从右往左==</p>
<h2 id="配置less-loader处理less文件"><a href="#配置less-loader处理less文件" class="headerlink" title="配置less-loader处理less文件"></a>配置less-loader处理less文件</h2><ul>
<li>安装依赖包</li>
</ul>
<pre><code class="bash">yarn add less-loader less -D</code></pre>
<ul>
<li>配置less-loader</li>
</ul>
<pre><code class="js">// 配置less-loader的规则
{
  // 匹配所有.less结尾的文件
  test: /\.less$/,
    // 使用css-loader 和 style-loader处理
    use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;]
}</code></pre>
<h2 id="配置file-loader处理图片"><a href="#配置file-loader处理图片" class="headerlink" title="配置file-loader处理图片"></a>配置file-loader处理图片</h2><ul>
<li>安装依赖包</li>
</ul>
<pre><code>yarn add file-loader -D</code></pre>
<ul>
<li>配置file-loader</li>
</ul>
<pre><code class="js">// file-loader配置
{
  test: /\.(png|jpg|gif)$/,
  use: &#39;file-loader&#39;
}</code></pre>
<h2 id="配置url-loader处理图片"><a href="#配置url-loader处理图片" class="headerlink" title="配置url-loader处理图片"></a>配置url-loader处理图片</h2><ul>
<li>安装</li>
</ul>
<pre><code class="js">yarn add url-loader file-loader -D</code></pre>
<ul>
<li>配置url-loader</li>
</ul>
<pre><code class="js">{
  test: /\.(png|jpg|gif)$/,
  use: {
    loader: &#39;url-loader&#39;,
    options: {
      limit: 20 * 1024
    }
  }
}</code></pre>
<h2 id="配置字体图标和音视频"><a href="#配置字体图标和音视频" class="headerlink" title="配置字体图标和音视频"></a>配置字体图标和音视频</h2><pre><code class="js">// 字体图标
{
  test: /\.(eot|svg|ttf|woff)$/,
  use: {
    loader: &#39;url-loader&#39;,
    options: {
      limit: 20 * 1024
    }
  }
},
{
  test: /\.(mp3|mp4|ogg)$/,
  use: {
    loader: &#39;url-loader&#39;,
    options: {
      limit: 20 * 1024
    }
  }
}</code></pre>
<h2 id="配置babel-loader"><a href="#配置babel-loader" class="headerlink" title="配置babel-loader"></a>配置babel-loader</h2><blockquote>
<p>babel可以把高版本的js语法转成低版本的js语法，保证运行的效果一样。能够兼容更多的浏览器。</p>
</blockquote>
<ul>
<li>安装依赖包</li>
</ul>
<pre><code class="js">yarn add  babel-loader @babel/core @babel/preset-env -D</code></pre>
<ul>
<li>配置babel</li>
</ul>
<pre><code class="js">{
  test: /\.m?js$/,
  exclude: /(node_modules|bower_components)/,
  use: {
    loader: &#39;babel-loader&#39;,
    options: {
      presets: [&#39;@babel/preset-env&#39;]
    }
  }
}</code></pre>
<h2 id="提取css到单独的文件中"><a href="#提取css到单独的文件中" class="headerlink" title="提取css到单独的文件中"></a>提取css到单独的文件中</h2><ul>
<li>安装插件</li>
</ul>
<pre><code class="js">yarn add mini-css-extract-plugin -D</code></pre>
<ul>
<li>配置插件</li>
</ul>
<pre><code class="js">const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

// 配置插件
plugins: [
  new MiniCssExtractPlugin({
    // 指定生成的css文件名和路径
    filename: &#39;./index.css&#39;,
  })
],</code></pre>
<ul>
<li>配置css和less的loader</li>
</ul>
<pre><code class="js">{
  test: /\.css$/,
  // css-loader只能够让webpack能够处理css文件
  // style-loader： 能够把处理好的css代码添加到页面中
  // MiniCssExtractPlugin.loader ; 把css提取到单独的css文件中
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;]
},
{
  test: /\.less$/,
  use: [MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;]
},</code></pre>
<h2 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h2><blockquote>
<p>webpack-dev-server不是用来打包的，而是用于启动一个服务器，，，，，当我们代码发生了改变，webpack-dev-server会重新打包（内存）并且会刷新浏览器，实时看到效果</p>
<p>最新版本的webpack5还不支持，需要降级处理</p>
</blockquote>
<p><img src="images/image-20201108181347423.png" alt="image-20201108181347423"></p>
<ul>
<li>安装包</li>
</ul>
<pre><code class="bash">yarn add webpack-dev-server -D

## 注意：如果需要使用webpack-dev-server  就不能使用最新的webpack5版本， 应该使用webpack 4</code></pre>
<ul>
<li>配置一个脚本</li>
</ul>
<pre><code class="js">
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;,
    &quot;serve&quot;: &quot;webpack-dev-server --config webpack.config.js&quot;
  },</code></pre>
<ul>
<li>使用dev脚本</li>
</ul>
<pre><code>yarn serve</code></pre>
<ul>
<li>常见配置</li>
</ul>
<pre><code class="js">  // devServer的配置
  devServer: {
    // 自定义端口
    port: 9090,
    // 自动打开浏览器
    open: true
  }</code></pre>
<h2 id="webpack处理vue文件"><a href="#webpack处理vue文件" class="headerlink" title="webpack处理vue文件"></a>webpack处理vue文件</h2><ul>
<li>新建了一个<code>App.vue</code>文件</li>
</ul>
<pre><code class="js">&lt;template&gt;
  &lt;div class=&quot;app&quot;&gt;我是根组件 ---{{msg}}  --&lt;demo&gt;&lt;/demo&gt; &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    return {
      msg: &#39;hello&#39;
    }
  },
}
&lt;/script&gt;

&lt;style&gt;
.app {
  background-color: red;
}
&lt;/style&gt;</code></pre>
<ul>
<li>在main.js中导入<code>App.vue</code>根组件，并且渲染成为根组件</li>
</ul>
<pre><code class="js">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

const vm = new Vue({
  el: &#39;#app&#39;,
  // 把App组件渲染成根组件
  render: c =&gt; c(App),
  // 把app渲染成为根组件
  // render: function(createElement) {
  //   return createElement(App)
  // }
})</code></pre>
<ul>
<li><p>报错，因为webpack处理不了vue文件</p>
</li>
<li><p>安装依赖包</p>
</li>
</ul>
<pre><code class="js">yarn add vue-loader@15.9.0 vue-template-compiler -D    </code></pre>
<ul>
<li>在webpack.config.js中配置vue-loader</li>
</ul>
<pre><code class="js">const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)

  plugins: [
    new VueLoaderPlugin()
  ],

    rules: [
      {
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      }
    ]</code></pre>
<p>12</p>
