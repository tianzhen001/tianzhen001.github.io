<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端工程化</title>
      <link href="articles/91c6.html"/>
      <url>articles/91c6.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>是一个流行的前端项目构建工具（打包工具），可以解决当前web开发过程中所面临的困境。</p><p>webpack提供了有好的<strong>模块化支持</strong>，以及<strong>代码的压缩混淆、处理js兼容问题、性能优化</strong>等强大的功能，从而让程序员把工作的重心放到具体的功能实现上，提高了开发的效率和项目的可维护性。</p><pre><code>npm i webpack webpack-cli -D 开发依赖在项目目录中，创建名为 webpack.config.js 的webpack 配置文件在webpack的配置文件中，初始化如下基本设置：module.exports = &#123;    mode: &#39;development&#39;     // 指定构建模式 production 上线阶段&#125;在package.json配置文件中，新增 dev 脚本如下：&quot;scripts&quot;: &#123;    &quot;dev&quot;:&quot;webpack&quot;      // npm run dev可以启动webpack进行项目的打包&#125;</code></pre><p>生成的资源被默认放在 dist 目录下，入口文件为 index.js 默认输出为 main.js</p><h4 id="配置-webpack-打包的入口与出口"><a href="#配置-webpack-打包的入口与出口" class="headerlink" title="配置 webpack 打包的入口与出口"></a>配置 webpack 打包的入口与出口</h4><p>可以在 webpack.config.js 中新增如下配置信息：</p><pre><code>const path = require(&#39;path&#39;)module.exports = &#123;    mode: &#39;development&#39;,     // 指定构建模式 production 上线阶段    entry: path.join(__dirName,&#39;./src/index.js&#39;),    output: &#123;        path: path.join(__dirName,&#39;./dist&#39;),        // 输出文件的存放路径        filename: &#39;bundle.js&#39; // 输出文件的名称    &#125;&#125;</code></pre><h4 id="配置-webpack-的自动打包功能"><a href="#配置-webpack-的自动打包功能" class="headerlink" title="配置 webpack 的自动打包功能"></a>配置 webpack 的自动打包功能</h4><p>npm i webpack-dev-server -D 安装支持项目自动打包的工具<br>修改 package.json中的 dev 命令</p><pre><code>&quot;scripts&quot;: &#123;    &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125;</code></pre><p>将 src -&gt; index.html 中 script 脚本的引用路径修改为 “bundle.js”</p><p>运行 npm run dev 命令，进行打包，即能实现自动打包效果</p><p><strong>1. webpack-dev-server 会启动一个实时打包的 http 服务器</strong></p><p><strong>2.webpack-dev-server打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的</strong></p><p>注意：访问 localhost:8080相当于访问了此服务器根的目录</p><h4 id="配置-html-webpack-plugin-生成预览页面"><a href="#配置-html-webpack-plugin-生成预览页面" class="headerlink" title="配置 html-webpack-plugin 生成预览页面"></a>配置 html-webpack-plugin 生成预览页面</h4><p>npm i html-webpack-plugin -D  属于开发依赖，是生成预览页面的插件</p><p>修改 webpack.config.js 文件头部区域，添加如下配置信息：</p><pre><code>// 导入生成预览页面的插件，得到一个构造函数const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)const htmlPlugin = new HtmlWebpackPlugin(&#123; // 创建插件实例    template: &#39;./src/index.html&#39;, // 指定要用到的模板文件    filename: &#39;index.html&#39; // 指定生成（拷贝）的文件名称，该文件存在于内存中，在目录中不显示&#125;)module.exports = &#123;    plugins: [ htmlPlugin ] // plugins 数组是 webpack 打包期间会用到的一些插件列表&#125;</code></pre><h4 id="设置自动打包相关的参数-实现自动打开浏览器"><a href="#设置自动打包相关的参数-实现自动打开浏览器" class="headerlink" title="设置自动打包相关的参数 实现自动打开浏览器"></a>设置自动打包相关的参数 实现自动打开浏览器</h4><p>package.json中配置</p><p>—open 打包完成后自动打开浏览器页面</p><p>—host 配置 IP 地址</p><p>—port 配置端口号</p><pre><code>&quot;webpack-dev-server --open --host 127.0.0.1 --port 3001&quot;</code></pre><h4 id="通过-loader-生态打包非-js-模块"><a href="#通过-loader-生态打包非-js-模块" class="headerlink" title="通过 loader 生态打包非 js 模块"></a>通过 loader 生态打包非 js 模块</h4><p>在实际开发过程中，webpack  默认只能打包以 .js 后缀名结尾的模块，其他非 .js 后缀名结尾的模块，webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错。</p><p>loader 加载器可以协助 webpack 打包处理特定的文件模块，比如：</p><p>less-loader 可以打包处理 .less相关的文件</p><p>sass-loader 可以打包处理 .scss相关的文件</p><p>url-loader 可以打包处理 css 中与 url 路径相关的文件</p><p>babel-loader 高级JS语法处理为普通js</p><h4 id="webpack-中加载器的基本使用"><a href="#webpack-中加载器的基本使用" class="headerlink" title="webpack 中加载器的基本使用"></a>webpack 中加载器的基本使用</h4><h5 id="打包处理css-less-scss-css的兼容性-文件"><a href="#打包处理css-less-scss-css的兼容性-文件" class="headerlink" title="打包处理css\less\scss\css的兼容性 文件"></a>打包处理css\less\scss\css的兼容性 文件</h5><p>运行 npm i style-loader css-loader -D  安装处理css文件的loader</p><p>在 webpack.config.js的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre><code>// 所有第三方文件模块的匹配规则module： &#123;    rules： [        &#123;test: /\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;]&#125;，        &#123;test: /\.less$/,use: [&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;less-loader&#39;]&#125;,        &#123;test: /\.scss$/, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]&#125;    ]&#125;</code></pre><p> test表示匹配的文件类型，use 表示对应要调用的 loader</p><p>use数组中指定的 loader 顺序是固定的，多个loader的调用顺序是从后往前调用  类似gulp的task()也是一步步进行的</p><p>配置postCSS自动添加css的兼容前缀</p><p>运行npm i postcss-loader autoprefixer -D</p><p>在项目的根目录中创建 postcss 的配置文件 postcss.config.js,并初始化如下配置：</p><pre><code>// 导入自动添加前缀的插件const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = &#123;    plugins: [ autoprefixer ] // 挂载插件&#125;</code></pre><p>在 webpack.config.js 的 module -&gt; rules 数组中，修改 css 的loader规则为：</p><pre><code>module： &#123;    rules： [        &#123;test: /\.css$/, use: [&#39;style-loader&#39;,&#39;css-loader&#39;, &#39;postcss-loader&#39;]&#125;     ]</code></pre><h4 id="打包样式表中的图片（路径）和字体文件"><a href="#打包样式表中的图片（路径）和字体文件" class="headerlink" title="打包样式表中的图片（路径）和字体文件"></a>打包样式表中的图片（路径）和字体文件</h4><p>npm i url-loader file-loader -D 其中file-loader是url-loader的内置依赖项，只需下载无需配置</p><p>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><pre><code>module: &#123;    rules: [        &#123;            test: /\.jpg|png|gif|bmp|webp|ttf|eot|svg|woff|woff2$/,            use: &#39;url-loader?limit=16940&#39;        &#125;    ]&#125;</code></pre><p>其中 ？ 之后的是loader 的参数项，limit 用来指定图片的大小，单位是字节（byte）,只有小于 limit 大小的图片才会被转为 base64 图片</p><h4 id="打包处理js文件中的高级语法"><a href="#打包处理js文件中的高级语法" class="headerlink" title="打包处理js文件中的高级语法"></a>打包处理js文件中的高级语法</h4><p>安装babel转换器相关的包：</p><p>npm i babel-loader @babel/core @babel/runtime -D</p><p>安装babel语法插件相关的包：</p><p>npm i  @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-class-properties -D</p><p>在项目中，创建 babel 配置文件 babel.config.js 并初始化基本配置如下：</p><pre><code>module.exports = &#123;    presets: [ &#39;@babel/preset-env&#39; ],    plugins: [&#39;@babel/plugin-transform-runtime&#39;, &#39;@babel/plugin-proposal-class-properties&#39;]&#125;</code></pre><p>在webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： </p><pre><code>// exclude 为排除项，表示 babel-loader 不需要处理 node_modules中的 js 文件&#123;test: /\.js$/,use: &#39;babel-loader&#39;,exclude: /node_modules/&#125;</code></pre><h3 id="Vue-单文件组件"><a href="#Vue-单文件组件" class="headerlink" title="Vue 单文件组件"></a>Vue 单文件组件</h3><h5 id="webpack中配置vue组件的加载器"><a href="#webpack中配置vue组件的加载器" class="headerlink" title="webpack中配置vue组件的加载器"></a>webpack中配置vue组件的加载器</h5><p>运行 npm i vue-loader vue-template-compiler -D</p><p>在 webpack.config.js 配置文件中添加 vue-loader 的配置项如下：</p><pre><code>const vueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;)module.exports = &#123;    module: &#123;        rules: [            &#123;test: /\.vue$/, use: &#39;vue-loader&#39;&#125;        ]    &#125;,    plugins: [        ...其他插件,        new vueLoaderPlugin()    ]&#125;</code></pre><h5 id="在webpack项目中使用vue"><a href="#在webpack项目中使用vue" class="headerlink" title="在webpack项目中使用vue"></a>在webpack项目中使用vue</h5><p>运行 npm i vue -S 安装vue</p><p>在src -&gt; index.js 入口文件中，通过 import Vue from ‘vue’ 来导入vue构造函数</p><p>创建 vue 实例对象，并指定要控制的 el 区域</p><p>通过 render 函数渲染 App根组件(阉割版的vue使用render函数渲染)</p><pre><code>import App from &#39;components/App.vue&#39;const vm = new Vue(&#123;    el: &#39;#app&#39;,    render: h =&gt; h(App)&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 大前端 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue的状态管理工具之vuex</title>
      <link href="articles/a957.html"/>
      <url>articles/a957.html</url>
      
        <content type="html"><![CDATA[<h1 id="vuex-概述"><a href="#vuex-概述" class="headerlink" title="vuex 概述"></a>vuex 概述</h1><p>目标：</p><ul><li>了解vuex的应用场景  (在哪用)</li><li>掌握vuex的基本使用  (怎么用)</li></ul><p><strong>vuex 是一个 vue 的状态管理工具,  状态即数据</strong></p><h2 id="回顾-组件之间共享状态-组件通信方案"><a href="#回顾-组件之间共享状态-组件通信方案" class="headerlink" title="回顾-组件之间共享状态 (组件通信方案)"></a>回顾-组件之间共享状态 (组件通信方案)</h2><p>默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)</p><blockquote><p> 状态 === 数据</p></blockquote><p><img src="/asset/image-20201029060003070.png" alt="image-20201029060003070"></p><p>组件之间共享状态的两种典型方式：</p><ul><li><p>父子之间 : props + $emit</p><p>父传子：props属性绑定</p><pre><code>&lt;son1 msg=&quot;msg&quot;&gt;&lt;/son1&gt;</code></pre><p>子传父：$emit事件绑定</p><pre><code>&lt;div&gt;    &lt;button @click=&quot;$emit(&#39;event-name&#39;)&quot;&gt;通知父组件&lt;/button&gt;&lt;/div&gt;</code></pre></li><li><p>非父子之间：EventBus 事件总线</p><ul><li><p>创建一个都能访问到的事件总线</p></li><li><p>在 A 组件中, bus.$emit</p></li><li>在 B 组件中, bus.$on</li></ul></li></ul><p>如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？</p><p>这里就要引入Vuex了。</p><h2 id="vuex基本概念"><a href="#vuex基本概念" class="headerlink" title="vuex基本概念"></a>vuex基本概念</h2><p><a href="https://vuex.vuejs.org/zh/guide/">中文文档</a></p><p>vuex是vue的状态管理工具，<strong>状态即数据</strong>。 状态管理就是集中管理vue中通用的一些数据</p><p>注意：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度</li></ul><p>Vuex就像近视眼镜, 你自然会知道什么时候需要用它~</p><h2 id="vuex的优点-方便的解决多组件的共享状态"><a href="#vuex的优点-方便的解决多组件的共享状态" class="headerlink" title="vuex的优点: 方便的解决多组件的共享状态"></a>vuex的优点: 方便的解决多组件的共享状态</h2><p> vuex的作用是解决多组件状态共享的问题。</p><ul><li>它是独立于组件而单独存在的，所有的组件都可以把它当作一座桥梁来进行通讯。</li><li><p>与事件总线（EventBus）相比，它具备额外的特点：</p><ul><li><strong>响应式</strong></li><li>操作更简洁</li></ul><p>代码量非常少, 但是需要熟悉</p></li></ul><p><img src="/asset/image-20201029061043482.png" alt="image-20201029061043482"></p><h2 id="什么数据适合存到vuex中"><a href="#什么数据适合存到vuex中" class="headerlink" title="什么数据适合存到vuex中"></a>什么数据适合存到vuex中</h2><p>一般情况下，只有  <strong>多个组件均需要共享的数据</strong> ，才有必要存储在vuex中，</p><p>对于某个组件中的私有数据，依旧存储在组件自身的data中。</p><p>例如：</p><ul><li>对于所有组件而言，当前登陆的用户信息是需要在全体组件之间共享的，则它可以放在vuex中</li><li>对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。</li></ul><h2 id="概述小结"><a href="#概述小结" class="headerlink" title="概述小结:"></a>概述小结:</h2><ol><li>vuex解决什么问题?   可以解决多组件共享状态的问题</li><li>什么样的数据, 适合存放到vuex?  多组件都需要用到的数据, 才往vuex中存</li></ol><p>vuex是响应式的, 只要vuex中的数据改了, 那么所有用到这个数据的地方, 都会更新!!!</p><h1 id="vuex入门"><a href="#vuex入门" class="headerlink" title="vuex入门"></a>vuex入门</h1><h2 id="初始化一个vuex项目"><a href="#初始化一个vuex项目" class="headerlink" title="初始化一个vuex项目"></a>初始化一个vuex项目</h2><ul><li>初始化命令</li></ul><pre><code>vue create 02-vuex</code></pre><ul><li>vue项目如何配置自动打开浏览器</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 1. 在项目的根目录，创建vue.config.js配置文件/*   我们可以通过vue.config.js文件覆盖vue-cli中webpack的配置文件*/module.exports = &#123;  // 导出配置  devServer: &#123;    open: true,    port: 3000  &#125;&#125;</code></pre><h2 id="需求-多组件共享数据"><a href="#需求-多组件共享数据" class="headerlink" title="需求: 多组件共享数据"></a>需求: 多组件共享数据</h2><p>对于如下三个组件（一个父组件，两个子组件）</p><p><img src="/asset/image-20201029080515105.png" alt="image-20201029080515105"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><p>1 创建项目</p><pre><code>vue create 03-vuex-demo</code></pre><p>2 创建三个组件, 目录如下</p><pre><code>|-components|--add-item.vue|--sub-item.vue|-App.vue</code></pre><p>3 源代码如下</p><p><code>App.vue</code></p><p>在入口组件中引入add-item和sub-item这两个子组件</p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div id="app">    <h1>根组件</h1>    <input type="text">    <add-item></add-item>    <hr>    <sub-item></sub-item>  </div></template><script>import AddItem from './components/add-item.vue'import SubItem from './components/sub-item.vue'export default &#123;  name: 'app',  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    AddItem,    SubItem  &#125;&#125;</script><style>#app &#123;  width: 300px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;</style></code></pre><p><code>main.js</code></p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue(&#123;  render: h => h(App)&#125;).$mount('#app')</code></pre><p><code>sub-item.vue</code></p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div class="box">    <h2>子组件 sub</h2>    从父组件中获取的值: <label></label>    <br>    <button>值-1</button>  </div></template><script>export default &#123;  name: 'SubItem'&#125;</script><style lang="css" scoped>.box&#123;  border: 3px solid #ccc;  width: 200px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;</style></code></pre><p><code>add-item.vue</code></p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div class="box">    <h2>子组件 add</h2>    从父组件中获取的值:<label></label>    <br />    <button>值+1</button>  </div></template><script>export default &#123;  name: 'AddItem'&#125;</script><style lang="css" scoped>.box &#123;  border: 3px solid #ccc;  width: 200px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;</style></code></pre><h2 id="vuex-的使用-创建仓库"><a href="#vuex-的使用-创建仓库" class="headerlink" title="vuex 的使用 - 创建仓库"></a>vuex 的使用 - 创建仓库</h2><p>1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code>yarn add vuex</code></pre><p>2 新建 <code>store/index.js</code> 专门存放 vuex</p><p>​    为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>3 创建仓库 <code>store/index.js</code> </p><pre class=" language-lang-jsx"><code class="language-lang-jsx">// 导入 vueimport Vue from 'vue'// 导入 vueximport Vuex from 'vuex'// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><p>4 在 main.js 中导入挂载到 Vue 实例上</p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'import store from './store'Vue.config.productionTip = falsenew Vue(&#123;  render: h => h(App),  store&#125;).$mount('#app')</code></pre><p>此刻起, 就成功创建了一个空仓库!!</p><h2 id="核心概念-state-状态"><a href="#核心概念-state-状态" class="headerlink" title="核心概念 - state 状态"></a>核心概念 - state 状态</h2><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><p>问题: 如何在组件中获取count?</p><ol><li>插值表达式 =》  </li><li>mapState 映射计算属性 =》  </li></ol><p><strong>1 原始形式- 插值表达式</strong></p><p><strong><code>App.vue</code></strong></p><p>组件中可以使用  <strong>this.$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre class=" language-lang-vue"><code class="language-lang-vue"><h1>state的数据 - &#123;&#123; $store.state.count &#125;&#125;</h1></code></pre><p><strong>计算属性</strong> - 将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre class=" language-lang-js"><code class="language-lang-js">// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"><h1>state的数据 - &#123;&#123; count &#125;&#125;</h1></code></pre><p>但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法</p><p><strong>2 辅助函数  - mapState</strong></p><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ： </p><p>第一步：导入mapState (mapState是vuex中的一个函数)</p><pre class=" language-lang-js"><code class="language-lang-js">import &#123; mapState &#125; from 'vuex'</code></pre><p>第二步：采用数组形式引入state属性</p><pre class=" language-lang-js"><code class="language-lang-js">mapState(['count'])</code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">count () &#123;    return this.$store.state.count&#125;</code></pre><p>第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</p><pre class=" language-lang-js"><code class="language-lang-js">  computed: &#123;    ...mapState(['count'])  &#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"> <div> state的数据：&#123;&#123; count &#125;&#125;</div></code></pre><h2 id="核心概念-mutations"><a href="#核心概念-mutations" class="headerlink" title="核心概念 - mutations"></a>核心概念 - mutations</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>通过 <code>strict: true</code> 可以开启严格模式</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><strong>定义mutations</strong></p><pre class=" language-lang-js"><code class="language-lang-js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;  &#125;&#125;)</code></pre><p><strong>格式说明</strong></p><p>mutations是一个对象，对象中存放修改state的方法</p><pre class=" language-lang-js"><code class="language-lang-js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><p>组件中提交 mutations</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">this.$store.commit('addCount')</code></pre><p><strong>解决问题: 两个子组件, 添加操作 add,  addN 实现</strong></p><h3 id="带参数的-mutation"><a href="#带参数的-mutation" class="headerlink" title="带参数的 mutation"></a>带参数的 mutation</h3><p>需求: 父组件也希望能改到数据</p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><p>1 提供mutation函数</p><pre class=" language-lang-js"><code class="language-lang-js">mutations: &#123;  ...  inputCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><p>2 注册事件</p><pre class=" language-lang-jsx"><code class="language-lang-jsx"><input type="text" :value="count" @input="handleInput"></code></pre><p>3 提交mutation</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">handleInput (e) &#123;  this.$store.commit('inputCount', +e.target.value)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">this.$store.commit('inputCount', &#123;  count: e.target.value&#125;)</code></pre><p><strong>解决问题:  addN 的实现</strong></p><h3 id="辅助函数-mapMutations"><a href="#辅助函数-mapMutations" class="headerlink" title="辅助函数 - mapMutations"></a><strong>辅助函数</strong> - mapMutations</h3><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">import  &#123; mapMutations &#125; from 'vuex'methods: &#123;    ...mapMutations(['addCount'])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit('addCount')      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre class=" language-lang-jsx"><code class="language-lang-jsx"><button @click="addCount()">值+1</button></code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="核心概念-actions"><a href="#核心概念-actions" class="headerlink" title="核心概念-actions"></a>核心概念-actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/asset/image-20201029074727223.png" alt="image-20201029074727223"></p><p><strong>定义actions</strong></p><pre class=" language-lang-js"><code class="language-lang-js">actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() => &#123;      context.commit('inputCount', num)    &#125;, 1000)  &#125;&#125;,</code></pre><p><strong>原始调用</strong> - $store (支持传参)</p><pre class=" language-lang-js"><code class="language-lang-js">setAsyncCount () &#123;  this.$store.dispatch('setAsyncCount', 200)&#125;</code></pre><p><strong>辅助函数</strong> -mapActions</p><blockquote><p>actions也有辅助函数，可以将action导入到组件中</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">import &#123; mapActions &#125; from 'vuex'methods: &#123;    ...mapActions(['setAsyncCount'])&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre class=" language-lang-vue"><code class="language-lang-vue"><button @click="setAsyncCount(200)">+异步</button></code></pre><h2 id="核心概念-getters"><a href="#核心概念-getters" class="headerlink" title="核心概念-getters"></a>核心概念-getters</h2><blockquote><p>除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre class=" language-lang-js"><code class="language-lang-js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><p><strong>定义getters</strong></p><pre class=" language-lang-js"><code class="language-lang-js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =>  state.list.filter(item => item > 5)  &#125;</code></pre><p>使用getters</p><p><strong>原始方式</strong> -$store</p><pre class=" language-lang-vue"><code class="language-lang-vue"><div>&#123;&#123; $store.getters.filterList &#125;&#125;</div></code></pre><p><strong>辅助函数</strong> - mapGetters</p><pre class=" language-lang-js"><code class="language-lang-js">computed: &#123;    ...mapGetters(['filterList'])&#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"> <div>&#123;&#123; filterList &#125;&#125;</div></code></pre><h2 id="核心概念-模块-module-进阶拓展"><a href="#核心概念-模块-module-进阶拓展" class="headerlink" title="核心概念 - 模块 module (进阶拓展)"></a>核心概念 - 模块 module (进阶拓展)</h2><blockquote><p><strong>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</strong></p></blockquote><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/asset/image-20201029155607101.png" alt="image-20201029155607101"></p><h3 id="模块定义-准备-state"><a href="#模块定义-准备-state" class="headerlink" title="模块定义 - 准备 state"></a><strong>模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  userInfo: &#123;    name: 'zs',    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的名称 title, desc  <code>modules/setting.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  title: '这是大标题',  desc: '描述真呀真不错'&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  =&gt;  <code>$store.state.setting.title</code></p><h3 id="命名空间-namespaced"><a href="#命名空间-namespaced" class="headerlink" title="命名空间 namespaced"></a>命名空间 namespaced</h3><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的</p><p>这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用, 如下图所示:</p><p><img src="/asset/image-20201029163627229.png" alt="image-20201029163627229"></p><p>但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置</p><p><code>modules/user.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  userInfo: &#123;    name: 'zs',    age: 18  &#125;,  myMsg: '我的数据'&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><p>提交模块中的mutation</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">全局的:   this.$store.commit('mutation函数名', 参数)模块中的: this.$store.commit('模块名/mutation函数名', 参数)</code></pre><p>namespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">computed: &#123;  // 全局的  ...mapState(['count']),  // 模块中的  ...mapState('user', ['myMsg']),&#125;,methods: &#123;  // 全局的  ...mapMutations(['addCount'])  // 模块中的  ...mapMutations('user', ['updateMsg'])&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue如何给各个组件设置title</title>
      <link href="articles/f8d7.html"/>
      <url>articles/f8d7.html</url>
      
        <content type="html"><![CDATA[<h3 id="vue如何给各个组件设置头部"><a href="#vue如何给各个组件设置头部" class="headerlink" title="vue如何给各个组件设置头部"></a>vue如何给各个组件设置头部</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><ol><li><p><strong>首先安装依赖</strong></p><pre><code>npm install vue-wechat-title --save</code></pre></li><li><p><strong>在Vue.use里面使用</strong></p><pre class=" language-lang-js"><code class="language-lang-js">//在main.js文件中配置import vueWeChatTitle from 'vue-wechat-title'Vue.use(vueWeChatTitle)//引入模块 import Entrance from 'vue-wechat-title'//在router的index.js文件中配置&#123;    path: '/',    //路由名称    name: 'Entrance',    //Entrance 引入模块名称    component: Entrance,    meta: &#123;        //声明title        title: '首页入口'        &#125;&#125;</code></pre></li><li><p><strong>调用</strong></p><pre class=" language-lang-js"><code class="language-lang-js">//调用 在router-view视图中添加修改title的指令<router-view v-wechat-title="$route.meta.title" /></code></pre></li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><ol><li><p><strong>首先安装依赖</strong></p><pre><code>npm install vue-wechat-title --save</code></pre></li><li><p><strong>配置 main.js</strong></p><pre><code>//设置titleimport vueWeChatTitle from &#39;vue-wechat-title&#39;Vue.use(vueWeChatTitle)router.beforeEach(to, form, next) =&gt; &#123;    //路由发生变化时，修改页面title    if （to.meta.title) &#123;        document.title = to.meta.title    &#125;    next()&#125;</code></pre></li></ol><ol><li><p><strong>在你需要改变的页面 第一个div 上加上v-wechat-title=”this.title”, title 是下面再 data 里面定义的数据.</strong></p><pre><code>&lt;div v-wechat-title=&quot;this.title&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>动态的改变title</p><pre class=" language-lang-js"><code class="language-lang-js">export default &#123;    data()&#123;        return &#123;            title: '你好啊'        &#125;    &#125;,    created()&#123;        //动态修改 使用方法写获取数据的方法 获取完成之后把文章的标题给title        this.title= 'sss'    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置指南</title>
      <link href="articles/dfd4.html"/>
      <url>articles/dfd4.html</url>
      
        <content type="html"><![CDATA[<h2 id="webpack概述"><a href="#webpack概述" class="headerlink" title="webpack概述"></a>webpack概述</h2><blockquote><p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler</em> )</p></blockquote><p><a href="https://www.webpackjs.com/">webpack中文网</a></p><p><a href="https://webpack.js.org/">webpack官网</a></p><h2 id="webpack做了什么"><a href="#webpack做了什么" class="headerlink" title="webpack做了什么"></a>webpack做了什么</h2><ul><li>语法转换<ul><li>less/sass转换成css</li><li>ES6转换成ES5</li><li>typescript转换成js</li></ul></li><li>html/css/js代码的压缩与合并（打包）</li><li>webpack可以在开发期间提供一个开发环境<ul><li>自动开启浏览器</li><li>自动监视文件变化</li><li>自动刷新浏览器</li></ul></li><li>项目一般都需要经过webpack打包之后才上线。</li></ul><h2 id="webpack模块说明"><a href="#webpack模块说明" class="headerlink" title="webpack模块说明"></a>webpack模块说明</h2><p>webpack会把所有的资源都当成模块</p><ul><li>css</li><li>js</li><li>图片</li><li>字体图标</li></ul><p>webpack给前端开发提供了模块化的开发环境</p><ul><li>对于js文件，webpack中支持AMD、CMD、commonJS、ES6模块化等语法</li><li>有了webpack，我们可以在前端代码中使用任意的模块化语法</li><li>可以在浏览器中使用nodejs的模块化语法<code>const $ = require(&#39;jquery&#39;)</code></li></ul><h2 id="webpack基本使用"><a href="#webpack基本使用" class="headerlink" title="webpack基本使用"></a>webpack基本使用</h2><ul><li>创建一个文件夹<code>webpack-demo</code></li><li>初始化项目 生成<code>package.json</code></li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn init -y</code></pre><ul><li>安装webpack的依赖包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add webpack webpack-cli -D</code></pre><ul><li>新建文件<code>src</code>和<code>dist</code>文件夹，，src用于提供源码，，dist用于存放打包后的文件</li><li><p>在src下新建了<code>index.js</code>文件，目的：对<code>src/index.js</code>文件进行打包</p></li><li><p>在package.json文件配置了打包的脚本</p></li></ul><pre class=" language-lang-js"><code class="language-lang-js">  "scripts": &#123;    "build": "webpack --config webpack.config.js"  &#125;</code></pre><ul><li>在项目的根目录，创建一个文件<code>webpack.config.js</code></li><li>执行打包命令</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn build</code></pre><h2 id="配置webpack的打包入口"><a href="#配置webpack的打包入口" class="headerlink" title="配置webpack的打包入口"></a>配置webpack的打包入口</h2><ul><li>在<code>webpack.config.js</code>文件中</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 这是webpack的配置文件 // webpack是运行在node环境中，webpack可以执行任意的node代码，包括可以使用node中模块。module.exports = &#123;  // 默认： ./src/index.js  entry: './src/app.js'&#125;</code></pre><h2 id="配置webpack的打包出口"><a href="#配置webpack的打包出口" class="headerlink" title="配置webpack的打包出口"></a>配置webpack的打包出口</h2><blockquote><p>配置webpack最终打包的文件的出口</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">  // 配置webpack打包出口  output: &#123;    // path： 打包出口的目录,默认 dist, 必须指定绝对路径    path: path.join(__dirname, 'lib'),    // filename: 打包出口的文件名字  默认 main.js    filename: 'bundle.js'  &#125;</code></pre><p>==如果要配置path，记得是绝对路径==</p><h2 id="配置webpack的打包模式"><a href="#配置webpack的打包模式" class="headerlink" title="配置webpack的打包模式"></a>配置webpack的打包模式</h2><pre class=" language-lang-js"><code class="language-lang-js">  // 打包模式  development|production  // development: 打包不会对进行压缩   打包快  // production: 打包会对代码进行压缩  上线  mode: 'development'</code></pre><h2 id="配置html-webpack-plugin插件"><a href="#配置html-webpack-plugin插件" class="headerlink" title="配置html-webpack-plugin插件"></a>配置html-webpack-plugin插件</h2><blockquote><p>html-webpack-plugin插件能够帮助我们自动在dist中生成一个html文件，并且会自动帮我们引入打包后的文件。</p></blockquote><ul><li>安装html-webpack-plugin插件</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add html-webpack-plugin -D</code></pre><ul><li>在<code>webpack.config.js</code>中配置</li></ul><pre class=" language-lang-js"><code class="language-lang-js">//1. 导入html-webpack-plugin插件const HtmlWebpackPlugin = require('html-webpack-plugin')// 2.配置webpack的插件，是一个数组plugins: [new HtmlWebpackPlugin(&#123;  // 生成html的模板  template: './src/index.html'&#125;)]</code></pre><h2 id="配置css-loader处理css文件"><a href="#配置css-loader处理css文件" class="headerlink" title="配置css-loader处理css文件"></a>配置css-loader处理css文件</h2><blockquote><p>webpack天生只能处理js文件，如果需要处理其他类型的文件，需要配置loader</p></blockquote><ul><li>安装依赖包</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add css-loader style-loader -D</code></pre><ul><li>配置loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">module: &#123;  rules: [    // 配置css-loader的规则    &#123;      // 匹配所有.css结尾的文件      test: /\.css$/,      // 使用css-loader 和 style-loader处理      use: ['style-loader', 'css-loader']    &#125;  ]&#125;</code></pre><p>==注意：loader加载顺序从右往左==</p><h2 id="配置less-loader处理less文件"><a href="#配置less-loader处理less文件" class="headerlink" title="配置less-loader处理less文件"></a>配置less-loader处理less文件</h2><ul><li>安装依赖包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add less-loader less -D</code></pre><ul><li>配置less-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 配置less-loader的规则&#123;  // 匹配所有.less结尾的文件  test: /\.less$/,    // 使用css-loader 和 style-loader处理    use: ['style-loader', 'css-loader', 'less-loader']&#125;</code></pre><h2 id="配置file-loader处理图片"><a href="#配置file-loader处理图片" class="headerlink" title="配置file-loader处理图片"></a>配置file-loader处理图片</h2><ul><li>安装依赖包</li></ul><pre><code>yarn add file-loader -D</code></pre><ul><li>配置file-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// file-loader配置&#123;  test: /\.(png|jpg|gif)$/,  use: 'file-loader'&#125;</code></pre><h2 id="配置url-loader处理图片"><a href="#配置url-loader处理图片" class="headerlink" title="配置url-loader处理图片"></a>配置url-loader处理图片</h2><ul><li>安装</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add url-loader file-loader -D</code></pre><ul><li>配置url-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.(png|jpg|gif)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;</code></pre><h2 id="配置字体图标和音视频"><a href="#配置字体图标和音视频" class="headerlink" title="配置字体图标和音视频"></a>配置字体图标和音视频</h2><pre class=" language-lang-js"><code class="language-lang-js">// 字体图标&#123;  test: /\.(eot|svg|ttf|woff)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;,&#123;  test: /\.(mp3|mp4|ogg)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;</code></pre><h2 id="配置babel-loader"><a href="#配置babel-loader" class="headerlink" title="配置babel-loader"></a>配置babel-loader</h2><blockquote><p>babel可以把高版本的js语法转成低版本的js语法，保证运行的效果一样。能够兼容更多的浏览器。</p></blockquote><ul><li>安装依赖包</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add  babel-loader @babel/core @babel/preset-env -D</code></pre><ul><li>配置babel</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.m?js$/,  exclude: /(node_modules|bower_components)/,  use: &#123;    loader: 'babel-loader',    options: &#123;      presets: ['@babel/preset-env']    &#125;  &#125;&#125;</code></pre><h2 id="提取css到单独的文件中"><a href="#提取css到单独的文件中" class="headerlink" title="提取css到单独的文件中"></a>提取css到单独的文件中</h2><ul><li>安装插件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add mini-css-extract-plugin -D</code></pre><ul><li>配置插件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');// 配置插件plugins: [  new MiniCssExtractPlugin(&#123;    // 指定生成的css文件名和路径    filename: './index.css',  &#125;)],</code></pre><ul><li>配置css和less的loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.css$/,  // css-loader只能够让webpack能够处理css文件  // style-loader： 能够把处理好的css代码添加到页面中  // MiniCssExtractPlugin.loader ; 把css提取到单独的css文件中  use: [MiniCssExtractPlugin.loader, 'css-loader']&#125;,&#123;  test: /\.less$/,  use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader']&#125;,</code></pre><h2 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h2><blockquote><p>webpack-dev-server不是用来打包的，而是用于启动一个服务器，，，，，当我们代码发生了改变，webpack-dev-server会重新打包（内存）并且会刷新浏览器，实时看到效果</p><p>最新版本的webpack5还不支持，需要降级处理</p></blockquote><p><img src="/images/image-20201108181347423.png" alt="image-20201108181347423"></p><ul><li>安装包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add webpack-dev-server -D## 注意：如果需要使用webpack-dev-server  就不能使用最新的webpack5版本， 应该使用webpack 4</code></pre><ul><li>配置一个脚本</li></ul><pre class=" language-lang-js"><code class="language-lang-js">  "scripts": &#123;    "build": "webpack --config webpack.config.js",    "serve": "webpack-dev-server --config webpack.config.js"  &#125;,</code></pre><ul><li>使用dev脚本</li></ul><pre><code>yarn serve</code></pre><ul><li>常见配置</li></ul><pre class=" language-lang-js"><code class="language-lang-js">  // devServer的配置  devServer: &#123;    // 自定义端口    port: 9090,    // 自动打开浏览器    open: true  &#125;</code></pre><h2 id="webpack处理vue文件"><a href="#webpack处理vue文件" class="headerlink" title="webpack处理vue文件"></a>webpack处理vue文件</h2><ul><li>新建了一个<code>App.vue</code>文件</li></ul><pre class=" language-lang-js"><code class="language-lang-js"><template>  <div class="app">我是根组件 ---&#123;&#123;msg&#125;&#125;  --<demo></demo> </div></template><script>export default &#123;  data() &#123;    return &#123;      msg: 'hello'    &#125;  &#125;,&#125;</script><style>.app &#123;  background-color: red;&#125;</style></code></pre><ul><li>在main.js中导入<code>App.vue</code>根组件，并且渲染成为根组件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'const vm = new Vue(&#123;  el: '##app',  // 把App组件渲染成根组件  render: c => c(App),  // 把app渲染成为根组件  // render: function(createElement) &#123;  //   return createElement(App)  // &#125;&#125;)</code></pre><ul><li><p>报错，因为webpack处理不了vue文件</p></li><li><p>安装依赖包</p></li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add vue-loader@15.9.0 vue-template-compiler -D</code></pre><ul><li>在webpack.config.js中配置vue-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const VueLoaderPlugin = require('vue-loader/lib/plugin')  plugins: [    new VueLoaderPlugin()  ],    rules: [      &#123;        test: /\.vue$/,        loader: 'vue-loader'      &#125;    ]</code></pre><p>12</p>]]></content>
      
      
      <categories>
          
          <category> 打包工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> 打包工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="articles/b9d3.html"/>
      <url>articles/b9d3.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-git基础入门"><a href="#1-git基础入门" class="headerlink" title="1. git基础入门"></a>1. git基础入门</h1><blockquote><p>Git是一款免费、开源的<strong>分布式</strong> <strong>版本控制系统</strong> ，用于敏捷高效地处理任何或小或大的项目。</p></blockquote><p><img src="/./images/reset.gif"></p><h2 id="1-1-git的安装"><a href="#1-1-git的安装" class="headerlink" title="1.1 git的安装"></a>1.1 git的安装</h2><p><a href="https://git-scm.com/download/win">下载地址</a></p><p>注意：</p><ol><li>不要安装在中文目录</li><li>不要使用桌面管理软件</li></ol><p>安装很简单，一直下一步即可。在任意的目录下右键，能看到菜单, 就表示安装成功了。</p><p>github账号注册 </p><p><a href="https://github.com/">github官网</a></p><h2 id="1-2-git三个区"><a href="#1-2-git三个区" class="headerlink" title="1.2 git三个区"></a>1.2 git三个区</h2><p>要对某个项目使用git进行管理，需要使用<code>git init</code>命令初始化git仓库<br><code>git init</code>会在当前目录生成一个隐藏文件夹 .git  不要去修改这个文件夹下的任意东西。</p><p>git仓库会分成三个区</p><p><strong>工作区</strong>：我们书写代码的地方，工作的目录就叫工作区。</p><p><strong>暂存区：</strong>暂时存储的区域，在git中，代码无法直接从工作区提交到仓库区，而是需要先从工作区添加到暂存区，然后才能从暂存区提交到仓库区。暂存区的目的是避免误操作。</p><p><strong>仓库区：</strong>将保存在暂存区域的内容永久转储到 Git 仓库中，生成版本号。生成版本号之后，就可以任何的回退到某一个具体的版本。</p><h2 id="1-3-git基本命令"><a href="#1-3-git基本命令" class="headerlink" title="1.3 git基本命令"></a>1.3 git基本命令</h2><h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><ul><li>作用：初始化git仓库，想要使用git对某个项目进行管理，需要<code>git init</code>进行初始化</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash"># 初始化仓库， 在当前目录下生成一个隐藏文件夹.gitgit init</code></pre><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><ul><li>作用：将文件由 <code>工作区</code> 添加到 <code>暂存区</code>，在git中，文件无法直接从工作区直接添加到仓库区，必须先从工作区添加到暂存区，再从暂存区添加到仓库区。</li><li>命令：<code>git add 文件名/目录名</code></li></ul><pre class=" language-lang-bash"><code class="language-lang-bash"># 将index.html添加到暂存区git add index.html# 将css目录下所有的文件添加到暂存区git add css# 添加当前目录下所有的文件git add .git add --all</code></pre><h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>作用：将文件由 <strong>暂存区</strong> 添加到 <strong>仓库区</strong>，生成版本号（存档）</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 将文件从暂存区提交到仓库git commit -m "提交说明"# 如果不写提交说明，会进入vi编辑器，没有写提交说明，是提交不成功的。 :q!来退出git commit   # 需要使用vi输入内容  vi编辑器常用操作</code></pre><h3 id="git-config配置"><a href="#git-config配置" class="headerlink" title="git config配置"></a>git config配置</h3><p>如果是第一次提交，需要配置提交者信息，推荐和github的账号邮箱一致</p><pre class=" language-lang-Bash"><code class="language-lang-Bash"># git config  user.name 你的目标用户名# git config  user.email 你的目标邮箱名# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。推荐配置github的用户名和密码git config  --global user.name  皮皮虾git config  --global user.email 2641543334@qq.com</code></pre><p>如果是之前已经配置了，想清空的话，可以使用如下命令：</p><pre class=" language-lang-js"><code class="language-lang-js">git config --global user.name '' git config --global user.email ''</code></pre><h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><ul><li>作用：查看文件的状态</li></ul><ul><li>命令：<code>git status</code> <ul><li>红色表示工作区中的文件需要提交</li><li>绿色表示暂存区中的文件需要提交</li></ul></li></ul><h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><ul><li>作用：查看提交日志</li><li><code>git log</code> 查看提交的日志</li><li><code>git log --oneline</code> 简洁的日志信息</li><li><code>git reflog</code> 查看<strong>所有的</strong>版本信息 ，包括回退的操作</li></ul><h2 id="1-4-git重置或版本回退"><a href="#1-4-git重置或版本回退" class="headerlink" title="1.4 git重置或版本回退"></a>1.4 git重置或版本回退</h2><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><ul><li>作用：版本回退，将代码恢复到已经提交的某一个版本中。</li><li><code>git reset --hard 版本号</code> 将代码回退到某个指定的版本(版本号只要有前几位即可)</li></ul><ul><li>当使用了<code>git reset</code>命令后，版本会回退，使用<code>git log</code>只能看到<strong>当前版本</strong>之前的信息。使用<code>git reflog</code>可以查看所有的版本信息</li></ul><h2 id="1-5-git忽视文件"><a href="#1-5-git忽视文件" class="headerlink" title="1.5 git忽视文件"></a>1.5 git忽视文件</h2><blockquote><p>在仓库中，有些文件是不想被git管理的，比如数据的配置密码、写代码的一些思路，node_modules等。git可以通过配置从而达到忽视掉一些文件，这样这些文件就可以不用提交了。</p></blockquote><ul><li>在仓库的根目录创建一个 的文件，文件名是固定的。</li><li>将不需要被git管理的文件路径添加到<code>.gitignore</code>中</li></ul><pre class=" language-lang-css"><code class="language-lang-css"># 忽视idea.txt文件idea.txt# 忽视css下的index.js文件css/index.js# 忽视css下的所有的js文件css/*.js# 忽视css文件夹css</code></pre><h1 id="2-git分支操作"><a href="#2-git分支操作" class="headerlink" title="2. git分支操作"></a>2. git分支操作</h1><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p><img src="/images/fenzhi.png" alt></p><h2 id="2-1-为什么要有分支？"><a href="#2-1-为什么要有分支？" class="headerlink" title="2.1 为什么要有分支？"></a>2.1 为什么要有分支？</h2><ul><li>如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。</li><li>有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。</li></ul><h2 id="2-2-git分支命令"><a href="#2-2-git分支命令" class="headerlink" title="2.2 git分支命令"></a>2.2 git分支命令</h2><blockquote><p>在git中，分支实质上仅仅是一个指针，每次代码提交后，这个分支指针就会向后移动，保证一直指向最后一次提交的的版本。git中使用HEAD指向当前分支</p></blockquote><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><ul><li><code>git branch 分支名称</code>创建分支，分支中的代码，在创建时与当前分支的内容完全相同。</li><li>git在第一次提交时，就有了一个叫<code>master</code>的主分支。</li><li><code>git branch dev</code>，创建了一个叫做dev的分支</li></ul><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul><li><code>git branch</code>可以查看所有的分支</li><li>在当前分支的前面会有一个<code>*</code></li><li>在git中，有一个特殊指针<code>HEAD</code>,永远会指向当前分支</li></ul><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul><li><code>git checkout 分支名称</code>切换分支  HEAD指针指向了另一个分支</li><li>在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。</li><li>提交代码时，会生产版本号，当前分支会指向最新的版本号。</li></ul><h3 id="创建并切换分支"><a href="#创建并切换分支" class="headerlink" title="创建并切换分支"></a>创建并切换分支</h3><ul><li><code>git checkout -b 分支名称</code> 创建并切换分支</li><li>切换分支会做两件事情<ul><li>创建一个新分支</li><li>把head指针指向当前的分支</li></ul></li></ul><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><ul><li><code>git branch -d 分支名称</code> 可以删除分支</li><li>注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。</li><li>注意：<code>master</code>分支是可以删除的，但是不推荐那么做。</li></ul><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ul><li><code>git merge 分支名称</code> 将其他分支的内容合并到当前分支。</li><li>在<code>master</code>分支中执行<code>git merge dev</code> 将<code>dev</code>分支中的代码合并到<code>master</code>分支</li><li><a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">分支合并</a></li></ul><h2 id="2-3-git合并冲突"><a href="#2-3-git合并冲突" class="headerlink" title="2.3 git合并冲突"></a>2.3 git合并冲突</h2><ul><li>对于同一个文件，如果有多个分支需要合并时，容易出现冲突。</li><li>合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。</li></ul><h1 id="3-git远程仓库"><a href="#3-git远程仓库" class="headerlink" title="3. git远程仓库"></a>3. git远程仓库</h1><h2 id="3-1-github与git"><a href="#3-1-github与git" class="headerlink" title="3.1 github与git"></a>3.1 github与git</h2><p>git与github没有直接的关系。</p><ul><li>git是一个版本控制工具。</li><li>github是一个<strong>代码托管平台</strong>，开源社区，是git的一个远程代码仓库。</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">//1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。//2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。//3. 创建git项目时，不能有中文。</code></pre><p><a href="https://github.com/">github官网</a></p><p><a href="https://git.oschina.net/">开源中国-git</a></p><p><img src="/images/image-20200722113838573.png" alt="image-20200722113838573"></p><h2 id="3-2-git-clone"><a href="#3-2-git-clone" class="headerlink" title="3.2 git clone"></a>3.2 git clone</h2><ul><li>作用：克隆远程仓库的代码到本地</li><li>git clone [远程仓库地址]</li><li><code>git clone https://github.com/itcastAAA666/myCode68.git</code>会在本地新建一个<code>test</code>文件夹，在test中包含了一个<code>.git</code>目录，用于保存所有的版本记录，同时test文件中还有最新的代码，你可以直接进行后续的开发和使用。</li><li>git克隆默认会使用远程仓库的项目名字，也可以自己指定。需要是使用以下命令：<code>git clone [远程仓库地址] [本地项目名]</code></li></ul><h2 id="3-3-git-push"><a href="#3-3-git-push" class="headerlink" title="3.3 git push"></a>3.3 git push</h2><ul><li>作用：将本地仓库中代码提交到远程仓库</li><li><code>git push 仓库地址 master</code> 在代码提交到远程仓库，注意master分支必须写，不能省略</li><li>例子：<code>git push https://github.com/itcastAAA666/myCode68.git master</code> 如果第一次使用，需要填写github的用户名和密码</li></ul><h2 id="3-4-git-pull"><a href="#3-4-git-pull" class="headerlink" title="3.4 git pull"></a>3.4 git pull</h2><ul><li>作用：将远程的代码下载到本地</li></ul><ul><li>通常在push前，需要先pull一次。</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash"># 获取远程仓库的更新，并且与本地的分支进行合并git pull</code></pre><h2 id="3-5-SSH免密码登陆"><a href="#3-5-SSH免密码登陆" class="headerlink" title="3.5 SSH免密码登陆"></a>3.5 SSH免密码登陆</h2><p>git支持多种数据传输协议：</p><ul><li>https协议：<code>https://github.com/你的注册名/test.git</code>  需要输入用户名和密码</li><li>ssh协议：<code>git@github.com:你的注册名/test.git</code>   可以配置免密码登录</li></ul><p>每次push或者pull代码，如果使用https协议，那么都需要输入用户名和密码进行身份的确认，非常麻烦。</p><ul><li>github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push</li><li>使用ssh协议，配置ssh免密码，可以做到免密码往github推送代码</li></ul><h2 id="3-6-SSH免密码登录配置"><a href="#3-6-SSH免密码登录配置" class="headerlink" title="3.6 SSH免密码登录配置"></a>3.6 SSH免密码登录配置</h2><p>注意：这些命令需要在bash中敲</p><ul><li>1 创建SSH Key：<code>ssh-keygen -t rsa</code>  <ul><li>key 钥匙的意思</li><li>gen— generate 生成，产生的意思</li></ul></li><li>2 在文件路径 <code>C:\用户\当前用户名\</code> 找到 <code>.ssh</code> 文件夹</li><li>3 文件夹中有两个文件：<ul><li>私钥：<code>id_rsa</code></li><li>公钥：<code>id_rsa.pub</code>   将公钥添加到github当中</li></ul></li><li>4 在 <code>github -&gt; settings -&gt; SSH and GPG keys</code>页面中，新创建SSH key</li><li>5 粘贴 公钥 <code>id_rsa.pub</code> 内容到对应文本框中</li><li>5 在github中新建仓库或者使用现在仓库，拿到<code>git@github.com:用户名/仓库名.git</code></li><li>6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了</li></ul><h2 id="3-7-git-remote"><a href="#3-7-git-remote" class="headerlink" title="3.7 git remote"></a>3.7 git remote</h2><p>每次push操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名</p><pre class=" language-lang-bash"><code class="language-lang-bash"># 给远程仓库设置一个别名git remote add 仓库别名 仓库地址git remote add pinyougou git@github.com:你的注册名/test.git# 使用如下来推送数据git push pinyougou master# 删除PPXCode这个别名git remote remove pinyougou</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法</title>
      <link href="articles/8daa.html"/>
      <url>articles/8daa.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><blockquote><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p></blockquote><h2 id="javascript的诞生"><a href="#javascript的诞生" class="headerlink" title="javascript的诞生"></a>javascript的诞生</h2><ul><li>1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。 </li><li>1994年10月，  Netscape （网景）公司，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。 </li><li><p>1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。 </p></li><li><p>Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。 因为当时网速特别的慢，很多表单的校验不适合放在服务器端进行校验。管理层对于这种脚本语言的设想是：<strong>功能不需要太强大，语法要简单，容易学习和使用</strong></p></li><li><p>1995年，Netscape 公司雇佣了程序员<code>Brendan Eich 布兰登·艾奇</code> 开发这种网页脚本语言。 </p></li><li><p>1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版，叫做<code>LiveScript</code>。它是一个大杂烩，语法有多个来源。</p><ul><li>基本语法：借鉴 C 语言和 Java 语言。</li><li>数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。</li><li>函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。</li><li>原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。</li><li>正则表达式：借鉴 Perl 语言。</li><li>字符串和数组处理：借鉴 Python 语言。</li></ul></li><li>为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。 <strong>后果：对于其他的编程语言，你需要只需要学习该语言提供的各种语法即可。对于javascript，你需要学习解决问题的各种模式，比如原型，原型链实现继承，闭包等等</strong></li><li>1995年 12月，Netscape 公司与 Sun 公司合作，后者允许将这种语言叫做 JavaScript。把LiveScript改名成了Javascript</li><li><strong>注意：javascript实质上和java没有什么关系</strong></li></ul><p><img src="/./images/java和javascript的区别.png" alt></p><h2 id="ECMAScript与Javascript的关系"><a href="#ECMAScript与Javascript的关系" class="headerlink" title="ECMAScript与Javascript的关系"></a>ECMAScript与Javascript的关系</h2><p>1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript ，这个版本就是1.0版。</p><p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript ，有两个原因。一是商标，Java是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA ，不是 Netscape ，这样有利于保证这门语言的开放性和中立性。</p><p>ECMAScript，简称ES，是由Ecma国际（欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）按照标准制定的一种脚本语言规范。</p><p>JavaScript是按ECMAScript规范实现的一种脚本语言，JavaScript除了实现了ECMAScript规范，还提供了BOM和DOM的操作。</p><h2 id="ECMAScript版本历史"><a href="#ECMAScript版本历史" class="headerlink" title="ECMAScript版本历史"></a>ECMAScript版本历史</h2><ul><li>ES1.0, 1997年06月发布</li><li>ES2.0, 1998年06月发布</li><li><p>ES3.0, 1999年12月发布</p></li><li><p>ES4.0,  由于关于语言的复杂性出现了分歧。放弃发布</p></li><li>ES5.0, 2009年12月发布， 增加了严格模式，增加了少量语法，为ES6铺路</li><li>ES6.0, 2015年6月发布，增加了大量的新概念和语法特性<ul><li><strong>第六版的名字， 可以叫做ECMAScript6.0(ES), 也可以叫做ECMAScript 2015（ES2015）</strong></li><li>ECMA组织决定以后每年6月份都会发布一版新的语法标准，比如ES7(ECMAScript 2016) </li><li><strong>通过我们说的ES6泛指ES5之后的下一代标准，涵盖了ES6, ES7, ES8….</strong>  </li></ul></li></ul><ul><li>参考书籍： <a href="https://es6.ruanyifeng.com/">https://es6.ruanyifeng.com/</a> </li></ul><h1 id="ES5-数组的新方法"><a href="#ES5-数组的新方法" class="headerlink" title="ES5-数组的新方法"></a>ES5-数组的新方法</h1><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach()</code> 方法对数组的每个元素执行一次提供的函数。功能等同于<code>for</code>循环.</p><p>应用场景：为一些相同的元素，绑定事件处理器！强调的是数组中每一项都要遍历</p><p>作用：</p><ul><li>1.只能是用来遍历 </li><li>2.一旦开始了遍历就停不下来</li><li>3.返回值是undefined  对于我们来说没有用</li></ul><p><strong>需求：遍历数组[“张飞”,”关羽”,”赵云”,”马超”]</strong></p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = ["张飞","关羽","赵云","马超"];//第一个参数：element，数组的每一项元素//第二个参数：index，数组的下标//第三个参数：array，正在遍历的数组arr.forEach(function(element, index, array)&#123;  console.log(element, index, array);&#125;);</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><p><strong>需求：遍历数组，求每一项的平方存在于一个数组中</strong></p><p><strong>作用：</strong></p><ul><li>1.可以循环遍历数组中的每一项数据</li><li>2.可以对循环遍历到的每一项数据进行操作</li><li>3.<strong>==重点应用场景: 对数组中的每一项数据进行操作,比如：给每数组中的每一项添加一个相同的样式==</strong></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [1,2,3,4,5];  // 1 4 9 16 25//第一个参数：element，数组的每一项元素//第二个参数：index，数组的下标//第三个参数：array，正在遍历的数组//返回值：一个新数组，每个元素都是回调函数的结果。var newArray = arr.map(function(element, index, array)&#123;  return element * element;&#125;);console.log(newArray);//[1,4,9,16,25]// 学了箭头函数之后的简写如下:var res = nums.map(item => item * item )</code></pre><p>案例：获取所有的名字</p><pre class=" language-lang-js"><code class="language-lang-js">let list = [      &#123; name: 'tom', age: 20 &#125;,      &#123; name: 'rose', age: 21 &#125;,      &#123; name: 'jack', age: 22 &#125;,      &#123; name: 'jerry', age: 19 &#125;    ]    let res = list.map(item => item.name)    console.log(res)</code></pre><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter</code>用于过滤掉“不合格”的元素<br>返回一个新数组，如果在回调函数中返回true，那么就留下来，如果返回false，就扔掉</p><p><strong>需求：遍历数组，将数组中工资超过5000的值找出来[1000, 5000, 20000, 3000, 10000, 800, 1500]</strong></p><p><strong>作用:</strong></p><ul><li>1.可以循环遍历数组中的每一项</li><li>2.可以对循环遍历到的数据进行判断</li><li>3.当条件成立时,使用了return true后会将满足条件的那一项存到一个新的数组当中</li><li>4.<strong>==重点应用场景:根据条件过滤数组中的数据==</strong></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arr = [1000, 5000, 20000, 3000, 10000, 800, 1500];//第一个参数：element，数组的每一项元素//第二个参数：index，数组的下标//第三个参数：array，正在遍历的数组//返回值：一个新数组，存储了所有返回true的元素var newArray = arr.filter(function(element, index, array)&#123;  if(element > 5000) &#123;    return false;  &#125;else &#123;    return true;  &#125;&#125;);console.log(newArray);//[1000, 5000, 3000, 800, 1500]// 学了箭头函数之后的简写如下:var res = nums.filter(item => item > 5000)</code></pre><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><p><code>some</code>用于遍历数组，如果有至少一个满足条件，就返回true，否则返回false。</p><p>**需求：遍历数组，查找数组中的某条数据 比如：查找[10, 20, 30, 40, 50, 60] 中的30</p><p>作用:</p><ul><li>1.可以用来循环遍历数组中的每一项</li><li>2.在回调函数中进行条件判断，如果return true执行之后，会阻止后续代码的遍历执行</li><li>3.重点应用场景: <strong>==条件成立时不再执行后续的循环==</strong></li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript"> // 查找数组有没有30 如果有，就不要再向下遍历了    let nums = [10, 20, 30, 40, 50, 60]    nums.some(function (item, index, arr) &#123;      // console.log(item,index,arr);      if (item == 30) &#123;        return true      &#125;      console.log(item);    &#125;)</code></pre><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><p><code>every</code>用于遍历数组，只有当所有的元素返回true，才返回true，否则返回false。</p><p><strong>需求：遍历数组，判断==整体==是否都满足条件</strong></p><p>作用：</p><ul><li>1.可以对数组中的每一项进行遍历，但是只打印第一项</li><li>2.对数组中的每一项进行判断，都满足条件则返回true,如果有一项不满足条件则返回false</li><li>3.==应用场景：重点是强调整体的一个处理结果，比如，某班考试成绩是否都合格==</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">// every 比如说: 考试完成之后,判断一下成绩当中是否有不及格的 如果都满足条件则返回true,有一个不满足条件则返回false    // var score = [100,99,96,93,65,74,41,25,62,18];    var score = [100,99,62,25,88];   var flag =  score.every(function(item,index,arr)&#123;      // console.log(item,index,arr);      return item > 60    &#125;)    console.log(flag);// 学了箭头函数之后的简写如下:var res = nums.every(item => item > 60)</code></pre><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><blockquote><p> <code>**reduce()**</code> 方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数，将其结果汇总为单个返回值 </p></blockquote><p>语法：<code>reduce(callback, initValue)</code></p><p>callback: 每个元素都会执行一次的回调函数</p><p>initValue: 初始值</p><p>callback的4个参数</p><ul><li>prev： 上一次的值，第一次为初始值</li><li>item:  当前值</li><li>index: 下标</li><li>arr: 数组</li></ul><p>案例：计算数组所有值的和</p><pre class=" language-lang-js"><code class="language-lang-js">let nums = [10, 20, 30, 40, 50, 60]var res = nums.reduce(function (prev, item) &#123;      // console.log(prev, item);      return prev + item &#125;, 0)console.log(res);// 学了箭头函数之后的简写如下:var res = nums.reduce((prev,item)=>prev + item)</code></pre><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><p>ES6中提供了两个声明变量的关键字：const和let </p></blockquote><h3 id="let的使用"><a href="#let的使用" class="headerlink" title="let的使用"></a>let的使用</h3><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>。</p><ul><li>let声明的变量只有在当前作用域有效</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  let a = 10;  var b = 1;&#125;a // ReferenceError: a is not defined.b // 1</code></pre><ul><li>不存在变量提升</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2;</code></pre><ul><li>不允许重复声明</li></ul><pre class=" language-lang-js"><code class="language-lang-js">let a = 10;let a = 1;//报错 Identifier 'a' has already been declared</code></pre><h3 id="const的使用"><a href="#const的使用" class="headerlink" title="const的使用"></a>const的使用</h3><p><code>const</code>声明一个只读的常量。常量：值不可以改变的量 </p><ul><li>const声明的量不可以改变</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const PI = 3.1415;PI = 3; //报错</code></pre><ul><li>const声明的变量必须赋值</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const num;</code></pre><ul><li>如果const声明了一个对象，仅仅保证地址不变</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const obj = &#123;name:'zs'&#125;;obj.age = 18;//正确obj = &#123;&#125;;//报错</code></pre><ul><li>其他用法和let一样</li></ul><pre class=" language-lang-js"><code class="language-lang-js">1. 只能在当前代码块中使用2. 不会提升3. 不能重复</code></pre><h3 id="let与const的使用场景"><a href="#let与const的使用场景" class="headerlink" title="let与const的使用场景"></a>let与const的使用场景</h3><pre class=" language-lang-js"><code class="language-lang-js">1. 如果声明的变量不需要改变，那么使用const2. 如果声明的变量需要改变，那么用let3. 学了const和let之后，尽量别用var</code></pre><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>以前，为变量赋值，只能直接指定值。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let a = 1;let b = 2;let c = 3;</code></pre><p>ES6 允许写成下面这样。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let [a, b, c] = [1, 2, 3];</code></pre><p>解构默认值</p><pre class=" language-lang-js"><code class="language-lang-js">let [a = 0, b, c] = [1, 2, 3];</code></pre><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>解构不仅可以用于数组，还可以用于对象。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;foo // "aaa"bar // "bbb"</code></pre><p>如果变量名与属性名不一致，必须写成下面这样。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world'</code></pre><p>函数的参数也可以使用解构赋值。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function add([x, y])&#123;  return x + y;&#125;add([1, 2]); // 3</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h3><p>传统的 JavaScript 语言，输出模板通常是这样写的（下面使用了 jQuery 的方法）。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">$('#result').append(  'There are <b>' + basket.count + '</b> ' +  'items in your basket, ' +  '<em>' + basket.onSale +  '</em> are on sale!');</code></pre><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">$('#result').append(`  There are <b>$&#123;basket.count&#125;</b> items   in your basket, <em>$&#123;basket.onSale&#125;</em>  are on sale!`);</code></pre><p>字符串模版的优点</p><ul><li>允许换行</li><li>可以使用插值  <code>$&#123;&#125;</code></li></ul><h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><ul><li><strong>includes()</strong>：返回布尔值，表示是否找到了参数字符串。</li><li><strong>startsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><strong>endsWith()</strong>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><strong>find是ES6新增的语法</strong></p><p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>。 </p><pre class=" language-lang-js"><code class="language-lang-js">// 获取第一个大于10的数var array1 = [5, 12, 8, 130, 44];var found = array1.find(function(element) &#123;  return element > 10;&#125;);console.log(found);</code></pre><h3 id="findexIndex"><a href="#findexIndex" class="headerlink" title="findexIndex"></a>findexIndex</h3><p><strong>findIndex是ES6新增的语法</strong></p><p><code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。否则返回-1。 </p><pre class=" language-lang-js"><code class="language-lang-js">// 获取第一个大于10的下标var array1 = [5, 12, 8, 130, 44];function findFirstLargeNumber(element) &#123;  return element > 13;&#125;console.log(array1.findIndex(findFirstLargeNumber));</code></pre><h2 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h2><h2 id="函数-箭头函数"><a href="#函数-箭头函数" class="headerlink" title="函数-箭头函数"></a>函数-箭头函数</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。</p><p>为什么叫Arrow Function？因为它的定义用的就是一个箭头：</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class=" language-lang-js"><code class="language-lang-js">var fn = function(x, y) &#123;    console.log(x + y);&#125;相当于//语法： (参数列表) => &#123;函数体&#125;var fn = (x, y) => &#123;    console.log(x + y);&#125;</code></pre><h3 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h3><ul><li>如果没有参数列表，使用()表示参数列表</li></ul><pre class=" language-lang-js"><code class="language-lang-js">var sum = () => &#123;    console.log('哈哈')&#125;;// 等同于：var sum = function() &#123;        console.log('哈哈')&#125;;</code></pre><ul><li>如果只有一个参数，可以省略()</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 等同于：var sum = function(n1) &#123;        console.log('哈哈')&#125;;var sum = n1 => &#123;    console.log('哈哈')&#125;;</code></pre><ul><li>如果有多个参数，需要使用()把参数列表括起来</li></ul><pre class=" language-lang-js"><code class="language-lang-js">var sum = function(n1, n2) &#123;        console.log('哈哈')&#125;;var sum = (n1, n2) => &#123;    console.log('哈哈')&#125;;</code></pre><h3 id="返回值详解"><a href="#返回值详解" class="headerlink" title="返回值详解"></a>返回值详解</h3><ul><li>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来</li></ul><pre class=" language-lang-js"><code class="language-lang-js">var sum = function(n1) &#123;        console.log('哈哈')&#125;;var sum = n1 => &#123;    console.log('哈哈')&#125;;</code></pre><ul><li>如果函数体只有一行一句，那么可以省略{}和return</li></ul><pre class=" language-lang-js"><code class="language-lang-js">var fn = function(n1, n2) &#123;    return n1 + n2;&#125;var fn = (n1, n2) => n1 + n2;</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ol><li>有一个数组<code>[1,3,5,7,9,2,4,6,8,10]</code>,请对数组进行排序</li><li>有一个数组<code>[&#39;a&#39;,&#39;ccc&#39;,&#39;bb&#39;,&#39;dddd&#39;]</code>,请按照字符串长度对数组进行排序</li><li>有一个数组，<code>[57,88,99,100,33,77]</code>,请保留60分以上的成绩，返回一个新的数组</li></ol><h3 id="箭头函数的注意点"><a href="#箭头函数的注意点" class="headerlink" title="箭头函数的注意点"></a>箭头函数的注意点</h3><ol><li>箭头函数内部没有this，因此箭头函数内部的this指向了外部的this</li><li>箭头函数不能作为构造函数，因为箭头函数没有this</li></ol><p>【定义一个对象，定时器打招呼】</p><p><strong>苦口婆心一下：箭头函数刚开始用，肯定会有点不习惯，但是任何东西都有一个习惯的过程，慢慢接受就好了，多用，多练</strong></p><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function log(x, y = 'World') &#123;  console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello</code></pre><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">function add(...values) &#123;&#125;add(2, 5, 3) // 10</code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>属性简写</p><p>方法简写</p><h3 id="展开运算符-…"><a href="#展开运算符-…" class="headerlink" title="展开运算符 …"></a>展开运算符 …</h3><p>扩展运算符（spread）是三个点（<code>...</code>）, 可用于 数组 / 对象 /Set 等结构；</p><p>下面开始在数组中应用扩展运算符</p><p><strong>（1）简单的应用</strong></p><pre class=" language-lang-js"><code class="language-lang-js">var arr = [1,2,3];console.log(...arr); // 输出 1,2,3</code></pre><p><strong>（2）复制数组</strong></p><pre class=" language-lang-js"><code class="language-lang-js">var arr = [1,2,3];// 1.使用concat合并数组会返回一个新的数组// 由于传的是空数组，所以返回的数组元素都是arr的，// 所以相当于复制出来一份arr数组, 并赋值给arr2var arr2 = arr.concat([]);// 2.ES6 的方法// 把arr数组展开到一个新的空数组中var arr3 = [...arr];</code></pre><p><strong>（3）合并数组</strong></p><pre class=" language-lang-js"><code class="language-lang-js">var arr = [1,2,3];var arr2 = [4,5,6];// 1.es5的方法，使用数组原生的concatarr.concat(arr2) // 输出 [1, 2, 3, 4, 5, 6]// 2.ES6 的合并数组[...arr, ...arr2]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js高级语法及进阶之路</title>
      <link href="articles/2a35.html"/>
      <url>articles/2a35.html</url>
      
        <content type="html"><![CDATA[<h2 id="推荐学习资源"><a href="#推荐学习资源" class="headerlink" title="推荐学习资源"></a>推荐学习资源</h2><ul><li>JavaScript 高级程序设计（第三版）<ul><li>前端的红宝书</li><li>建议每一个前端都完整的看一遍</li></ul></li><li>JavaScript面向对象编程指南（第2版）</li><li>JavaScript面向对象精要</li><li>JavaScript 权威指南</li><li>JavaScript 语言精粹</li><li>你不知道的 JavaScript</li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p><img src="/./images/mxdxkf.png" alt="面向对象编程"></p><h2 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h2><blockquote><p>Everything is object （万物皆对象）</p></blockquote><p><img src="/./images/20160823024542444.jpg" alt="万物皆对象"></p><p>对象到底是什么，我们可以从两次层次来理解。</p><p><strong>(1) 对象是具体事物的抽象。</strong></p><p>一本书、一辆汽车、一个人都可以是对象，当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p>问： 书是对象吗</p><p><strong>(2)对象是无序键值对的集合，其属性可以包含基本值、对象或者函数</strong></p><p>每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p><h2 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h2><p>面向对象编程 —— <code>Object Oriented Programming</code>，简称 OOP ，是一种编程开发思想。</p><p>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。<br>因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p><h2 id="面向对象编程的三大特性："><a href="#面向对象编程的三大特性：" class="headerlink" title="面向对象编程的三大特性："></a>面向对象编程的三大特性：</h2><ul><li>封装性<ul><li>将功能的具体实现，全部封装到对象的内部，外界使用对象时，只需要关注对象提供的方法如何使用，而不需要关心对象的内部具体实现，这就是封装。</li></ul></li><li>继承性<ul><li>在js中，继承的概念很简单，一个对象没有的一些属性和方法，另外一个对象有，拿过来用，就实现了继承。</li><li><strong>注意：在其他语言里面，继承是类与类之间的关系，在js中，是对象与对象之间的关系。</strong></li></ul></li><li>[多态性]<ul><li>多态是在强类型的语言中才有的。js是弱类型语言，所以JS不支持多态</li></ul></li></ul><h1 id="对象、原型、原型链"><a href="#对象、原型、原型链" class="headerlink" title="对象、原型、原型链"></a>对象、原型、原型链</h1><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><h3 id="内置构造函数创建"><a href="#内置构造函数创建" class="headerlink" title="内置构造函数创建"></a>内置构造函数创建</h3><p>我们可以直接通过 <code>new Object()</code> 创建：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//在js中，对象有动态特性，可以随时的给一个对象增加属性或者删除属性。var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123;  console.log(this.name)&#125;</code></pre><p>缺点：麻烦，每个属性都需要添加。</p><h3 id="对象字面量创建"><a href="#对象字面量创建" class="headerlink" title="对象字面量创建"></a>对象字面量创建</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">var person = &#123;  name: 'Jack',  age: 18,  sayName: function () &#123;    console.log(this.name)  &#125;&#125;</code></pre><p>缺点：如果要批量生成多个对象，应该怎么办?代码很冗余</p><h3 id="简单改进：工厂函数"><a href="#简单改进：工厂函数" class="headerlink" title="简单改进：工厂函数"></a>简单改进：工厂函数</h3><p>我们可以写一个函数，解决代码重复问题：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function createPerson (name, age) &#123;  return &#123;    name: name,    age: age,    sayName: function () &#123;      console.log(this.name)    &#125;  &#125;&#125;</code></pre><p>然后生成实例对象：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18)</code></pre><p>缺点：但却没有解决对象识别的问题，创建出来的对象都是Object类型的。</p><h3 id="继续改进：构造函数"><a href="#继续改进：构造函数" class="headerlink" title="继续改进：构造函数"></a>继续改进：构造函数</h3><p>构造函数是一个函数，用于实例化对象，需要配合new操作符使用。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Person (name, age) &#123;  this.name = name  this.age = age  this.sayName = function () &#123;    console.log(this.name)  &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // => Jackvar p2 = new Person('Mike', 23)p2.sayName() // => Mike</code></pre><p>而要创建 <code>Person</code> 实例，则必须使用 <code>new</code> 操作符。<br>以这种方式调用构造函数会经历以下 4 个步骤：</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）</li><li>执行构造函数中的代码</li><li>返回新对象</li></ol><p><strong>构造函数需要配合new操作符使用才有意义，构造函数首字母都需要大写</strong></p><h3 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h3><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Person (name, age) &#123;  this.name = name  this.age = age  this.type = 'human'  this.sayHello = function () &#123;    console.log('hello ' + this.name)  &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // => false</code></pre><p>解决方案：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function sayHello() &#123;  console.log('hello ' + this.name)&#125;function Person (name, age) &#123;  this.name = name  this.age = age  this.type = 'human'  this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // => true</code></pre><p>缺点：会暴漏很多的函数，容易造成全局变量污染。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="原型基本概念"><a href="#原型基本概念" class="headerlink" title="原型基本概念"></a>原型基本概念</h3><p>Javascript 规定，每一个函数都有一个 <code>prototype</code> 属性，指向另一个对象。<br>这个对象的所有属性和方法，都会被构造函数的实例继承。</p><p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Person (name, age) &#123;  this.name = name  this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123;  console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // => true</code></pre><p>这时所有实例的 <code>type</code> 属性和 <code>sayName()</code> 方法，其实都是同一个内存地址</p><h3 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h3><p>构造函数：构造函数就是一个函数，配合new可以新建对象。</p><p>实例：通过构造函数实例化出来的对象我们把它叫做构造函数的实例。一个构造函数可以有很多实例。</p><p>原型：每一个构造函数都有一个属性<code>prototype</code>，函数的prototype属性值就是原型。通过构造函数创建出来的实例能够直接使用原型上的属性和方法。</p><p><img src="/./images/原型三角关系.jpg" alt></p><p>思考：内置对象中，有很多的方法，这些方法存在哪里？</p><h3 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><code>__proto__</code></h3><p>任意一个对象，都会有<code>__proto__</code>属性，这个属性指向了构造函数的prototype属性，也就是原型对象。</p><p>获取原型对象：</p><ul><li>通过<code>构造函数.prototype</code>可以获取</li><li>通过<code>实例.__proto__</code>可以获取（隐式原型）</li><li>它们指向了同一个对象<code>构造函数.prototype === 实例.__proto__</code></li></ul><p><strong>注意：<code>__proto__</code>是浏览器的一个隐藏（私有）属性，IE浏览器不支持，不要通过它来修改原型里的内容，如果要修改原型中的内容，使用构造函数.prototype去修改</strong></p><h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>默认情况下，原型对象中只包含了一个属性：constructor，constructor属性指向了当前的构造函数。</p><p><img src="/./images/sanjiao.png" alt></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><h3 id="原型链概念"><a href="#原型链概念" class="headerlink" title="原型链概念"></a>原型链概念</h3><p>任何一个对象，都有原型对象，原型对象本身又是一个对象，所以原型对象也有自己的原型对象，这样一环扣一环就形成了一个链式结构，我们把这个链式结构称为：原型链。</p><p>绘制对象的原型链结构：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//1. var p = new Person();//2. var o = new Object();//3. var arr = new Array();//4. var date = new Date();//5. Math//6. 查看一个div的原型链结构</code></pre><p>总结：Object.prototype是原型链的尽头，Object.prototype的原型是null。</p><p><img src="/./images/proto.png" alt></p><h3 id="属性查找原则"><a href="#属性查找原则" class="headerlink" title="属性查找原则"></a>属性查找原则</h3><p>如果是获取操作</p><ol><li>会先在自身上查找，如果没有</li><li>则根据<code>__proto__</code>对应的原型去找，如果没有</li><li>一直找到<code>Object.prototyp</code>，如果没有，那就找不到了。</li></ol><p>测试题1</p><pre class=" language-lang-js"><code class="language-lang-js">function Person(name) &#123;  this.name = name;&#125;Person.prototype.name = "ls";Person.prototype.money = 100;var p = new Person("zs");console.log(p.name);console.log(p.money);</code></pre><p>测试题2</p><pre class=" language-lang-js"><code class="language-lang-js">function Person(name) &#123;  this.name = name&#125;Person.prototype.name = "ls";Person.prototype.money = 100;var p = new Person();console.log(p.name);console.log(p.money);</code></pre><p>测试题3</p><pre class=" language-lang-js"><code class="language-lang-js">function Person(name) &#123;  if (name) &#123;    this.name = name;  &#125;&#125;Person.prototype.name = "ls";Person.prototype.money = 100;var p = new Person();console.log(p.name);console.log(p.money);</code></pre><h3 id="属性设置原则"><a href="#属性设置原则" class="headerlink" title="属性设置原则"></a>属性设置原则</h3><p>只会修改对象自身的属性，如果自身没有这个属性，那么就会添加这个属性，并不会修改原型中的属性。</p><pre class=" language-lang-js"><code class="language-lang-js">function Person() &#123;&#125;var p = new Person();Person.prototype.money = 200;console.log(p.money);p.money = 300;console.log(p.money);console.log(Person.prototype.money);</code></pre><h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><blockquote><p>作用域：变量起作用的区域，也就是说：变量定义后，可以在哪个范围内使用该变量。</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">var num = 11;//全局变量function fn()&#123;  var num1 = 22;//局部变量  console.log(num);  // 全局变量在任何地方都能访问到  console.log(num1);  &#125;console.log(num);</code></pre><p>在js里只有全局作用域和函数作用域。</p><p>函数作用域是在函数定义的时候作用域就确定下来了，和函数在哪调用无关。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var num = 123;function f1() &#123;  console.log(num);&#125;function f2()&#123;  var num = 456;  f1();&#125;f2();//打印啥？</code></pre><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><blockquote><p>作用域链：只要是函数，就会形成一个作用域，如果这个函数被嵌套在其他函数中，那么外部函数也有自己的作用域，这个一直往上到全局环境，就形成了一个作用域链。</p></blockquote><p><code>变量的搜索原则</code>：</p><ol><li>从当前作用域开始查找是否声明了该变量，如果存在，那么就直接返回这个变量的值。</li><li>如果不存在，就会往上一层作用域查询，如果存在，就返回。</li><li>如果不存在，一直查询到全局作用域，如果存在，就返回。如果在全局中也没有找到该变量会报错</li></ol><h3 id="作用域链练习"><a href="#作用域链练习" class="headerlink" title="作用域链练习"></a>作用域链练习</h3><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 1 var num = 10;fn1();function fn1() &#123;  console.log(num);  // ?  var num = 20;  console.log(num);  // ?&#125;console.log(num);    // ?// 2 -- 改造上面的面试题var num = 10;fn1();function fn1() &#123;  console.log(num);  // ?  num = 20;  console.log(num);  // ?&#125;console.log(num);    // ?// 3var num = 123function f1(num) &#123;    console.log(num) // ?&#125;function f2() &#123;    var num = 456    f1(num)&#125;f2()// 4var num1 = 10;var num2 = 20;function fn(num1) &#123;  num1 = 100;  num2 = 200;  num3 = 300;  console.log(num1);  console.log(num2);  console.log(num3);  var num3;&#125;fn();console.log(num1);console.log(num2);console.log(num3);</code></pre><h2 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h2><blockquote><p>根据函数内部this的指向不同，可以将函数的调用模式分成4种</p></blockquote><ol><li>函数调用模式</li><li>方法调用模式</li><li>构造函数调用模式</li><li>上下文调用模式（借用方法模式）</li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">函数：当一个函数不是一个对象的属性时，我们称之为函数。方法：当一个函数被保存为对象的一个属性时，我们称之为方法。</code></pre><h3 id="函数调用模式"><a href="#函数调用模式" class="headerlink" title="函数调用模式"></a>函数调用模式</h3><font color="red">如果一个函数不是一个对象的属性时，就是被当做一个函数来进行调用的。此时this指向了window</font><pre class=" language-lang-javascript"><code class="language-lang-javascript">function fn()&#123;  console.log(this);//指向window&#125;fn();</code></pre><h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><font color="red">当一个函数被保存为对象的一个属性时，我们称之为一个方法。当一个方法被调用时，this被绑定到当前对象</font><pre class=" language-lang-javascript"><code class="language-lang-javascript">var obj = &#123;  sayHi:function()&#123;    console.log(this);//在方法调用模式中，this指向调用当前方法的对象。  &#125;&#125;obj.sayHi();</code></pre><h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><font color="red">如果函数是通过new关键字进行调用的，此时this被绑定到创建出来的新对象上。</font><pre class=" language-lang-javascript"><code class="language-lang-javascript">function Person()&#123;  console.log(this);&#125;Person();//this指向什么？var p = new Person();//this指向什么？</code></pre><p><strong>总结：分析this的问题，主要就是区分函数的调用模式，看函数是怎么被调用的。</strong></p><ul><li>猜猜看：</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 分析思路：1. 看this是哪个函数的  2. 看这个函数是怎么调用的，处于什么调用模式// 1var age = 38;var obj = &#123;    age: 18,    getAge: function () &#123;        console.log(this.age);    &#125;&#125;var f = obj.getAge;f();//???// 2var age = 38;var obj = &#123;  age:18,  getAge:function () &#123;    console.log(this.age);//???    function foo()&#123;      console.log(this.age);//????    &#125;    foo();  &#125;&#125;obj.getAge();obj["getAge"]();// 3var length = 10function fn() &#123;    console.log(this.length)&#125;var obj = &#123;    length: 5,    method: function (fn) &#123;        fn()         arguments[0]();    &#125;&#125;obj.method(fn, 10, 5);</code></pre><p>几种特殊的this指向</p><ul><li>定时器中的this指向了window，因为定时器的function最终是由window来调用的。</li><li>事件中的this指向的是当前的元素，在事件触发的时候，浏览器让当前元素调用了function</li></ul><h3 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h3><blockquote><p>上下文调用模式也叫方法借用模式，分为apply与call</p><p>使用方法： 函数.call() 或者 函数.apply()</p></blockquote><h4 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h4><p>call方法可以调用一个函数，并且可以指定这个函数的<code>this</code>指向</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//所有的函数都可以使用call进行调用//参数1：指定函数的this，如果不传，则this指向window//其余参数：和函数的参数列表一模一样。//说白了，call方法也可以和()一样，进行函数调用，call方法的第一个参数可以指定函数内部的this指向。fn.call(thisArg, arg1, arg2, arg2);</code></pre><ul><li>借用对象的方法</li></ul><h4 id="伪数组与数组"><a href="#伪数组与数组" class="headerlink" title="伪数组与数组"></a>伪数组与数组</h4><blockquote><p>伪数组也叫类数组</p></blockquote><ol><li>伪数组其实就是一个对象，但是跟数组一样，伪数组也会有<code>length</code>属性，也有<code>0,1,2,3</code>等属性。</li><li>伪数组并没有数组的方法，不能使用<code>push/pop</code>等方法</li><li>伪数组可以跟数组一样进行遍历，通过下标操作。</li><li>常见的伪数组：<code>arguments</code>、<code>document.getElementsByTagName的返回值</code>、<code>jQuery对象</code></li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">var arrayLike = &#123;  0:"张三",  1:"李四",  2:"王五",  length:3&#125;//伪数组可以和数组一样进行遍历</code></pre><ul><li>伪数组借用数组的方法</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">Array.prototype.push.call(arrLike, "赵六");</code></pre><h4 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h4><p><code>apply()</code>方法的作用和 <code>call()</code>方法类似，只有一个区别，就是<code>apply()</code>方法接受的是<strong>一个包含多个参数的数组</strong>。而<code>call()</code>方法接受的是<strong>若干个参数的列表</strong></p><p>call和apply的使用场景：</p><ul><li>如果参数比较少，使用call会更加简洁</li><li>如果参数存放在数组中，此时需要使用apply</li></ul><h4 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h4><p><strong>bind()</strong>方法创建一个新的函数, 可以绑定新的函数的<code>this</code>指向</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 返回值：新的函数// 参数：新函数的this指向，当绑定了新函数的this指向后，无论使用何种调用模式，this都不会改变。var newFn = fn.bind(window);</code></pre><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><blockquote><p>递归函数：函数内部直接或者间接的调用自己</p></blockquote><p>递归的要求：</p><ol><li>自己调用自己（直接或者间接）</li><li>要有结束条件（出口）</li></ol><p>递归函数主要是<code>化归思想</code> ,将一个复杂的问题简单化，主要用于解决数学中的一些问题居多。</p><ul><li>把要解决的问题，归结为已经解决的问题上。</li><li>一定要考虑什么时候结束让函数结束，也就是停止递归（一定要有已知条件）</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的基本概念"><a href="#闭包的基本概念" class="headerlink" title="闭包的基本概念"></a>闭包的基本概念</h2><p><code>闭包（closure）</code>是JavaScript语言的一个难点，也是JavaScript的一个特色，很多高级的应用都要依靠闭包来实现。</p><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><blockquote><p>在<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>闭包</strong>（英语：Closure），又称<strong>词法闭包</strong>（Lexical Closure）或<strong>函数闭包</strong>（function closures），是引用了自由变量的函数 </p></blockquote><p>在JavaScript中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则产生闭包。</p><p>产生闭包的条件</p><pre class=" language-lang-js"><code class="language-lang-js">当内部函数访问了外部函数的变量的时候，就会形成闭包。</code></pre><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><blockquote><p>保护私有变量不被修改</p></blockquote><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>需求：统计一个函数的调用次数</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var count = 0;function fn()&#123;  count++;  console.log("我被调用了，调用次数是"+count);&#125;fn();fn();fn();</code></pre><p>缺点：count是全局变量，不安全。</p><p>使用闭包解决这个问题！！！！</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">function outer()&#123;  var count = 0; // 私有变量, 将count保护起来了  function add()&#123;    count++;    console.log("当前count"+count);  &#125;  return add;&#125;var result = outer();result();</code></pre><h2 id="闭包经典面试题"><a href="#闭包经典面试题" class="headerlink" title="闭包经典面试题"></a>闭包经典面试题</h2><ol><li><p>点击按钮, 打印当前按钮的下标</p></li><li><pre class=" language-lang-js"><code class="language-lang-js">function fn() &#123;    var a = 0;    return function() &#123;        a++;        console.log(a);    &#125;&#125;var f1 = fn();f1();f1();f1();var f2 = fn();f2();f2();f2();f2();</code></pre></li><li><pre class=" language-lang-js"><code class="language-lang-js">function f1()&#123;    var name="abc";    return function()&#123;        console.log(name);    &#125;&#125;var fn = f1();var name="张三";fn();</code></pre></li></ol><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote><p>现实生活中的继承，子承父业, 如儿子继承了父辈的财产，公司等</p><p>js中的继承，一个对象可以使用另一个对象中的方法或属性</p></blockquote><p>继承的目的:  方便代码的复用</p><pre class=" language-lang-js"><code class="language-lang-js">var lw = &#123;    skill: "翻墙",    age: 28&#125;function Person()&#123;&#125;var xm = new Person();// 如何实现让xm可以使用到lw对象上的skill属性???xm.skill; // ==> 翻墙</code></pre><h2 id="JS常见的几种继承模式"><a href="#JS常见的几种继承模式" class="headerlink" title="JS常见的几种继承模式"></a>JS常见的几种继承模式</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><p>一个对象可以访问构造函数的原型中的属性和方法，那么如果想要让一个对象增加某些属性和方法，只需要把这些属性和方法放到原型对象中即可。这样就实现了继承, 称之为原型链继承</p><ul><li>直接给原型增加属性和方法</li><li>原型替换（注意：constructor）</li></ul><pre class=" language-lang-js"><code class="language-lang-js">var Person = function() &#123;&#125;;Person.prototype.n = 1;var p1 = new Person();Person.prototype = &#123;    n: 2,    m: 3&#125;var p2 = new Person();console.log(p1.n);console.log(p1.m);console.log(p2.n);console.log(p2.m);</code></pre><h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><blockquote><p>从构造函数中继承到构造函数中的成员</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">function Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;function Chinese(name, age, gender, skin)&#123;    this.name = name;    this.age = age;    this.gender = gender;    // 以上代码重复，在构造函数Person中已经给this添加    this.skin = skin;&#125;// 重写构造函数Chinesefunction Chinese(name, age, gender, skin)&#123;    // 借用Person构造函数，继承到name、age、gender属性    Person.call(this, name, age, gender);    this.skin = skin;&#125;</code></pre><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote><p>借用构造函数 + 原型链继承组合在一起使用</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">function Person(name, age, gender)&#123;    this.name = name;    this.age = age;    this.gender = gender;&#125;// Person原型上的sayHi方法Person.prototype.sayHi = function()&#123;    console.log("hello, 我是" + this.name);&#125;function Chinese(name, age, gender, skin)&#123;    // 借用Person构造函数，继承到name、age、gender属性    Person.call(this, name, age, gender);    this.skin = skin;&#125;var xm = new Chinese("xm", 20, "male", "黄色");// xm有name/age/gender属性从Person构造函数中继承到的// 那么如何让Chinese的实例对象xm去继承到Person原型上的sayHi方法???xm.sayHi();</code></pre><pre class=" language-lang-js"><code class="language-lang-js">function Person() &#123;    this.name = "is me";    this.color = ["lime", "red"];&#125;function Chinese() &#123;&#125;Chinese.prototype = new Person();var c1 = new Chinese();var c2 = new Chinese();c1.name = "change";c1.color.push("black");console.log(c2.name);console.log(c2.color);</code></pre><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote><p>正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用，经常用于表单校验，高级搜索等。</p></blockquote><h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><p>【07-正则表达式的创建.html】</p><p>构造函数的方式</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var regExp = new RegExp(/\d/);</code></pre><p>正则字面量</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var regExp = /\d/;</code></pre><p>正则的使用</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">/\d/.test("aaa1");</code></pre><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><blockquote><p>正则表达式由一些普通字符和元字符组成，普通字符包括大小写字母、数字等，而元字符则具有特殊的含义。</p></blockquote><h3 id="常见元字符"><a href="#常见元字符" class="headerlink" title="常见元字符"></a>常见元字符</h3><p><code>|</code>表示或，优先级最低</p><p><code>()</code>优先级最高，表示分组</p><h3 id="字符类的元字符"><a href="#字符类的元字符" class="headerlink" title="字符类的元字符"></a>字符类的元字符</h3><p><code>[]</code>在正则表达式中表示一个字符的位置，[]里面写这个位置可以出现的字符。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">console.log(/[abc]/);//匹配a,b,c</code></pre><p><code>[^]</code>在中扩号中的^表示非的意思。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//^表示该位置不可以出现的字符console.log(/[^abc]/);//匹配除了a，b，c以外的其他字符</code></pre><p><code>[a-z]</code> <code>[1-9]</code>表示范围</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">console.log(/[a-z]/.test("d"));//小写字母console.log(/[A-Z]/.test("d"));//大写字母console.log(/[0-9]/.test("8"));//数字console.log(/[a-zA-Z0-9]/);//所有的小写字母和大写字母以及数字</code></pre><h3 id="边界类元字符"><a href="#边界类元字符" class="headerlink" title="边界类元字符"></a>边界类元字符</h3><blockquote><p>我们前面学习的正则只要有满足的条件的就会返回true，并不能做到精确的匹配。</p></blockquote><p>【12-正则边界.html】</p><p>^表示开头   <strong><em>[]里面的^表示取反</em></strong></p><p>$表示结尾</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">console.log(/^chuan/.test("dachuan"));//必须以chuan开头console.log(/chuan$/.test("chuang"));//必须以chuan结尾console.log(/^chuan$/.test("chuan"));//精确匹配chuan//精确匹配chuan,表示必须是这个console.log(/^chuan$/.test("chuanchuan"));//fasle</code></pre><h3 id="量词类元字符"><a href="#量词类元字符" class="headerlink" title="量词类元字符"></a>量词类元字符</h3><blockquote><p>量词用来控制出现的次数，一般来说量词和边界会一起使用</p></blockquote><p>【13-正则量词.html】</p><ol><li><code>*</code>表示能够出现0次或者更多次，x&gt;=0;</li><li><code>+</code>表示能够出现1次或者多次，x&gt;=1</li><li><code>?</code>表示能够出现0次或者1次，x=0或者x=1</li><li><code>&#123;n&#125;</code>表示能够出现n次</li><li><code>&#123;n,&#125;</code>表示能够出现n次或者n次以上</li><li><code>&#123;n,m&#125;</code>表示能够出现n-m次</li></ol><p>思考：如何使用{}来表示*+? </p><h2 id="正则的使用"><a href="#正则的使用" class="headerlink" title="正则的使用"></a>正则的使用</h2><h3 id="正则测试"><a href="#正则测试" class="headerlink" title="正则测试"></a>正则测试</h3><ol><li><p>验证QQ</p><ul><li>只能是数字</li><li>开头不能是0</li><li>长度为5-11位</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var qqReg = /^[1-9]\d&#123;4,10&#125;$/;</code></pre></li><li><p>验证手机</p><ul><li>11位数字组成</li><li>号段13[0-9] 147 15[0-9] 17[0178] 18[0-9]</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var mobileReg = /^(13[0-9]|147|15[0-9]|17[0178]|18[0-9])\d&#123;8&#125;$/;</code></pre></li><li><p>验证邮箱</p><ul><li>前面是字母或者数字</li><li>必须有@</li><li>@后面是字母或者数字</li><li>必须有.</li><li>.后面是字母或者数字</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var emailReg = /^\w+@\w+(\.\w+)+$/;</code></pre></li><li><p>验证姓名</p><ul><li>只能是汉字</li><li>长度2-6位之间</li><li>汉字范围[\u4e00-\u9fa5]</li></ul><pre class=" language-lang-javascript"><code class="language-lang-javascript">var nameReg = /^[\u4e00-\u9fa5]&#123;2,6&#125;$/;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Js高级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FormData的使用</title>
      <link href="articles/2162.html"/>
      <url>articles/2162.html</url>
      
        <content type="html"><![CDATA[<h1 id="FormData使用方法详解"><a href="#FormData使用方法详解" class="headerlink" title="FormData使用方法详解"></a>FormData使用方法详解</h1><p>FormData的主要用途有两个：</p><h6 id="1、将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。"><a href="#1、将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。" class="headerlink" title="1、将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。"></a>1、将form表单元素的name与value进行组合，实现表单数据的序列化，从而减少表单元素的拼接，提高工作效率。</h6><h6 id="2、异步上传文件"><a href="#2、异步上传文件" class="headerlink" title="2、异步上传文件"></a>2、异步上传文件</h6><h4 id="一、创建formData对象"><a href="#一、创建formData对象" class="headerlink" title="一、创建formData对象"></a>一、创建formData对象</h4><h6 id="1、创建一个空对象："><a href="#1、创建一个空对象：" class="headerlink" title="1、创建一个空对象："></a>1、创建一个空对象：</h6><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//可以通过append()方法来追加数据formdata.append("name","laotie");//通过get方法对值进行读取console.log(formdata.get("name"));//laotie//通过set方法对值进行设置formdata.set("name","laoliu");console.log(formdata.get("name"));//laoliu</code></pre><h6 id="2、通过表单对formData进行初始化"><a href="#2、通过表单对formData进行初始化" class="headerlink" title="2、通过表单对formData进行初始化"></a>2、通过表单对formData进行初始化</h6><p>创建表单：</p><pre><code>  &lt;form id=&quot;advForm&quot;&gt;    &lt;p&gt;广告名称：&lt;input type=&quot;text&quot; name=&quot;advName&quot; value=&quot;xixi&quot;&gt;&lt;/p&gt;    &lt;p&gt;广告类别：&lt;select name=&quot;advType&quot;&gt;        &lt;option value=&quot;1&quot;&gt;轮播图&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;轮播图底部广告&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;热门回收广告&lt;/option&gt;        &lt;option value=&quot;4&quot;&gt;优品精选广告&lt;/option&gt;      &lt;/select&gt;&lt;/p&gt;    &lt;p&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;添加&quot;&gt;&lt;/p&gt;  &lt;/form&gt;</code></pre><p>通过表单元素作为参数，实现对formData的初始化：</p><pre class=" language-lang-js"><code class="language-lang-js">//获得表单按钮元素var btn=document.querySelector("#btn");//为按钮添加点击事件btn.onclick=function()&#123;    //根据ID获得页面当中的form表单元素    var form=document.querySelector("#advForm");    //将获得的表单元素作为参数，对formData进行初始化    var formdata=new FormData(form);    //通过get方法获得name为advName元素的value值    console.log(formdata.get("advName"));//xixi    //通过get方法获得name为advType元素的value值    console.log(formdata.get("advType"));//1&#125;</code></pre><h4 id="二、操作方法"><a href="#二、操作方法" class="headerlink" title="二、操作方法"></a>二、操作方法</h4><h6 id="1、通过get-key-与getAll-key-来获取相对应的值"><a href="#1、通过get-key-与getAll-key-来获取相对应的值" class="headerlink" title="1、通过get(key)与getAll(key)来获取相对应的值"></a>1、通过get(key)与getAll(key)来获取相对应的值</h6><pre class=" language-lang-js"><code class="language-lang-js">// 获取key为age的第一个值formdata.get("age");// 获取key为age的所有值，返回值为数组类型formdata.getAll("age");</code></pre><h6 id="2、通过append-key-value-在数据末尾追加数据"><a href="#2、通过append-key-value-在数据末尾追加数据" class="headerlink" title="2、通过append(key,value)在数据末尾追加数据"></a>2、通过append(key,value)在数据末尾追加数据</h6><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");//通过append()方法在末尾追加key为name值为laoli的数据formdata.append("name","laoli");//通过append()方法在末尾追加key为name值为laotie的数据formdata.append("name","laotie");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoliu//通过getAll方法读取key为name的所有console.log(formdata.getAll("name"));//["laoliu", "laoli", "laotie"]</code></pre><h6 id="3、通过set-key-value-来设置修改数据"><a href="#3、通过set-key-value-来设置修改数据" class="headerlink" title="3、通过set(key, value)来设置修改数据"></a>3、通过set(key, value)来设置修改数据</h6><p>key的值不存在，会添加一条数据</p><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//如果key的值不存在会为数据添加一个key为name值为laoliu的数据formdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoli</code></pre><p>key的值存在，会修改对应的value值</p><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");//通过append()方法在末尾追加key为name值为laoliu2的数据formdata.append("name","laoliu2");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoliu//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoliu", "laoliu2"]//将存在的key为name的值修改为laoliformdata.set("name","laoli");//通过get方法读取key为name的第一个值console.log(formdata.get("name"));//laoli//通过getAll方法读取key为name的所有值console.log(formdata.getAll("name"));//["laoli"]</code></pre><h6 id="4、通过has-key-来判断是否存在对应的key值"><a href="#4、通过has-key-来判断是否存在对应的key值" class="headerlink" title="4、通过has(key)来判断是否存在对应的key值"></a>4、通过has(key)来判断是否存在对应的key值</h6><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");//判断是否包含key为name的数据console.log(formdata.has("name"));//true//判断是否包含key为age的数据console.log(formdata.has("age"));//false</code></pre><h6 id="5、通过delete-key-可以删除数据"><a href="#5、通过delete-key-可以删除数据" class="headerlink" title="5、通过delete(key)可以删除数据"></a>5、通过delete(key)可以删除数据</h6><pre class=" language-lang-js"><code class="language-lang-js">//通过FormData构造函数创建一个空对象var formdata=new FormData();//通过append()方法在末尾追加key为name值为laoliu的数据formdata.append("name","laoliu");console.log(formdata.get("name"));//laoliu//删除key为name的值formdata.delete("name");console.log(formdata.get("name"));//null</code></pre><h4 id="三、通过XMLHttpRequest发送数据"><a href="#三、通过XMLHttpRequest发送数据" class="headerlink" title="三、通过XMLHttpRequest发送数据"></a>三、通过XMLHttpRequest发送数据</h4><p>创建表单：</p><pre><code>  &lt;form id=&quot;advForm&quot;&gt;    &lt;p&gt;广告名称：&lt;input type=&quot;text&quot; name=&quot;advName&quot; value=&quot;xixi&quot;&gt;&lt;/p&gt;    &lt;p&gt;广告类别：&lt;select name=&quot;advType&quot;&gt;        &lt;option value=&quot;1&quot;&gt;轮播图&lt;/option&gt;        &lt;option value=&quot;2&quot;&gt;轮播图底部广告&lt;/option&gt;        &lt;option value=&quot;3&quot;&gt;热门回收广告&lt;/option&gt;        &lt;option value=&quot;4&quot;&gt;优品精选广告&lt;/option&gt;      &lt;/select&gt;&lt;/p&gt;    &lt;p&gt;广告图片：&lt;input type=&quot;file&quot; name=&quot;advPic&quot;&gt;&lt;/p&gt;    &lt;p&gt;广告地址：&lt;input type=&quot;text&quot; name=&quot;advUrl&quot;&gt;&lt;/p&gt;    &lt;p&gt;广告排序：&lt;input type=&quot;text&quot; name=&quot;orderBy&quot;&gt;&lt;/p&gt;    &lt;p&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;添加&quot;&gt;&lt;/p&gt;  &lt;/form&gt;</code></pre><p>发送数据：</p><pre class=" language-lang-js"><code class="language-lang-js">var btn=document.querySelector("#btn");btn.onclick=function()&#123;        var formdata=new FormData(document.getElementById("advForm"));    var xhr=new XMLHttpRequest();    xhr.open("post","http://127.0.0.1/adv");    xhr.send(formdata);    xhr.onload=function()&#123;        if(xhr.status==200)&#123;            //...        &#125;    &#125;&#125;</code></pre><p>本文引自：<a href="https://www.cnblogs.com/clj2017/p/9321652.html">https://www.cnblogs.com/clj2017/p/9321652.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最好用的js库之jQuery</title>
      <link href="articles/8e14.html"/>
      <url>articles/8e14.html</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-初体验"><a href="#jQuery-初体验" class="headerlink" title="jQuery 初体验"></a>jQuery 初体验</h2><p>【02-让 div 显示与设置内容.html】</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(document).ready(function () &#123;  $("#btn1").click(function () &#123;    // 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。    $("div").show(200);  &#125;);  $("#btn2").click(function () &#123;    $("div").text("我是内容");  &#125;);&#125;);</code></pre><p>使用 jQuery 的优点</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//1. 获取元素的方式非常的简单，而且非常的丰富//2. jQuery的隐式迭代特性，不再需要书写for循环语句。//3. 使用jQuery完全不用考虑兼容性问题。//4. jQuery提供了一系列动画相关的函数，使用非常方便。//5. 代码简单、粗暴。</code></pre><p><strong>没有对比，就没有伤害，有了对比，处处戳中要害。</strong></p><h2 id="什么是-jQuery"><a href="#什么是-jQuery" class="headerlink" title="什么是 jQuery?"></a>什么是 jQuery?</h2><blockquote><p>jQuery 是一个快速的、轻量的、功能丰富的 js 库。</p></blockquote><p>jQuery 的官网 <a href="http://jquery.com/">http://jquery.com/</a></p><p>jQuery 就是一个 js 库，使用 jQuery 的话，会比使用 JavaScript 更简单。</p><p>js 库：把一些常用到的方法写到一个单独的 js 文件，使用的时候直接去引用这 js 文件就可以了。（animate.js、common.js）</p><h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>入口函数的好处：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">1. 等待文档加载完成，保证能够获取到元素2. 形成了一个沙箱，防止全局变量污染。</code></pre><p>两种写法：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//第一种写法$(document).ready(function () &#123;&#125;);//第二种写法$(function () &#123;&#125;);</code></pre><p>jQuery 入口函数与 js 入口函数的对比</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">1.    JavaScript的入口函数要等到页面中所有资源（包括图片、文件）加载完成才开始执行。2.    jQuery的入口函数只会等待文档树加载完成就开始执行，并不会等待图片、文件的加载。</code></pre><h2 id="jQuery-使用步骤"><a href="#jQuery-使用步骤" class="headerlink" title="jQuery 使用步骤"></a>jQuery 使用步骤</h2><ol><li>引包（引入 js 文件）</li></ol><pre class=" language-lang-html"><code class="language-lang-html"><script src="jquery-1.11.1.js"></script></code></pre><ol><li>写上入口函数</li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(document).ready(function () &#123;&#125;);// 或者$(function () &#123;&#125;);</code></pre><ol><li>在入口函数内部实现功能</li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">$("#btnShowDiv").click(function () &#123;  $("div").show(1000);&#125;);</code></pre><h2 id="jQuery-对象与-DOM-对象-重点"><a href="#jQuery-对象与-DOM-对象-重点" class="headerlink" title="jQuery 对象与 DOM 对象(重点)"></a>jQuery 对象与 DOM 对象(重点)</h2><p>基本概念：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">1. DOM对象：使用JavaScript中的方法获取页面中的元素返回的对象就是dom对象。2. jQuery对象：jquery对象就是使用jquery的方法获取页面中的元素返回的对象就是jQuery对象。3. jQuery对象其实就是DOM对象的包装集（包装了DOM对象的集合（伪数组））</code></pre><p>jQuery 对象与 DOM 对象的区别：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">1. DOM对象与jQuery对象的方法不能混用。2. DOM对象可以和jQuery对象相互转化</code></pre><p>DOM 对象转换成 jQuery 对象：【联想记忆：花钱】</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var $obj = $(domObj);// $(document).ready(function()&#123;&#125;); 就是典型的DOM对象转jQuery对象</code></pre><p>jQuery 对象转换成 DOM 对象：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">var $li = $("li");//第一种方法（推荐使用）$li[0]//第二种方法$li.get(0)</code></pre><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h2 id="什么是-jQuery-选择器"><a href="#什么是-jQuery-选择器" class="headerlink" title="什么是 jQuery 选择器"></a>什么是 jQuery 选择器</h2><p>jQuery 选择器是 jQuery 为我们提供的一组方法，让我们更加方便的获取到页面中的元素。注意：jQuery 选择器返回的是 jQuery 对象。</p><p>jQuery 选择器有很多，基本兼容了 CSS1 到 CSS3 所有的选择器，并且 jQuery 还添加了很多更加复杂的选择器。【查看 jQuery 文档】</p><p>jQuery 选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。所以我们平时真正能用到的只是少数的最常用的选择器。</p><h2 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h2><blockquote><p>jQuery 完全兼容 css 选择器</p></blockquote><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>ID 选择器</td><td>$(“#id”);</td><td style="text-align:left">获取指定 ID 的元素</td></tr><tr><td>类选择器</td><td>$(“.class”);</td><td style="text-align:left">获取同一类 class 的元素</td></tr><tr><td>标签选择器</td><td>$(“div”);</td><td style="text-align:left">获取同一类标签的所有元素</td></tr><tr><td>并集选择器</td><td>$(“div,p,li”);</td><td style="text-align:left">使用逗号分隔，只要符合条件之一就可。</td></tr><tr><td>交集选择器</td><td>$(“div.redClass”);</td><td style="text-align:left">获取 class 为 redClass 的 div 元素</td></tr><tr><td>子代选择器</td><td>$(“ul&gt;li”);</td><td style="text-align:left">使用&gt;号，获取儿子层级的元素，注意，并不会获取孙子层级的元素</td></tr><tr><td>后代选择器</td><td>$(“ul li”);</td><td style="text-align:left">使用空格，代表后代选择器，获取 ul 下的所有 li 元素，包括孙子等</td></tr></tbody></table></div><blockquote><p>跟 CSS 的选择器一模一样。</p></blockquote><h2 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h2><blockquote><p>这类选择器都带冒号:</p></blockquote><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>:eq（index）</td><td>$(“li:eq(2)”).css(“color”, ”red”);</td><td style="text-align:left">获取到的 li 元素中，选择索引号为 2 的元素，索引号 index 从 0 开始。</td></tr><tr><td>:odd</td><td>$(“li:odd”).css(“color”, ”red”);</td><td style="text-align:left">获取到的 li 元素中，选择索引号为奇数的元素</td></tr><tr><td>:even</td><td>$(“li:even”).css(“color”, ”red”);</td><td style="text-align:left">获取到的 li 元素中，选择索引号为偶数的元素</td></tr><tr><td>:first</td><td>$(“li:first”).css(“color”, ”red”);</td><td style="text-align:left">获取到的 li 元素中的第一个</td></tr><tr><td>:last</td><td>$(“li:last”).css(“color”, ”red”);</td><td style="text-align:left">获取到的 li 元素中的最后一个</td></tr></tbody></table></div><h2 id="筛选选择器-方法"><a href="#筛选选择器-方法" class="headerlink" title="筛选选择器(方法)"></a>筛选选择器(方法)</h2><blockquote><p>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，<code>筛选选择器</code>主要是方法。</p></blockquote><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>children(selector)</td><td>$(“ul”).children(“li”)</td><td style="text-align:left">获取当前元素的所有子元素中的 li 元素</td></tr><tr><td>find(selector)</td><td>$(“ul”).find(“li”);</td><td style="text-align:left">获取当前元素中的后代元素中的 li 元素</td></tr><tr><td>siblings(selector)</td><td>$(“#first”).siblings(“li”);</td><td style="text-align:left">查找兄弟节点，不包括自己本身。</td></tr><tr><td>parent()</td><td>$(“#first”).parent();</td><td style="text-align:left">查找父亲</td></tr><tr><td>eq(index)</td><td>$(“li”).eq(2);</td><td style="text-align:left">相当于<code>$(&quot;li:eq(2)&quot;)</code>,index 从 0 开始</td></tr><tr><td>next()</td><td>$(“li”).next()</td><td style="text-align:left">找下一个兄弟</td></tr><tr><td>prev()</td><td>$(“li”).prev()</td><td style="text-align:left">找上一次兄弟</td></tr></tbody></table></div><h2 id="其他补充-mouseover-与-mouseenter"><a href="#其他补充-mouseover-与-mouseenter" class="headerlink" title="其他补充: mouseover 与 mouseenter"></a>其他补充: mouseover 与 mouseenter</h2><blockquote><p>mouseover 和 mouseoverenter 都有鼠标经过的意思，但是在注册鼠标经过事件的时候，推荐使用<code>mouseenter</code></p></blockquote><p><a href="http://www.w3school.com.cn/tiy/t.asp?f=jquery_event_mouseenter_mouseover">mouseenter 与 mouseover 的不同</a></p><ol><li>mouseover 与 mouseout 是一对事件，当鼠标经过当前元素或者当前元素的子元素的时候，mouseover 事件都会触发【事件冒泡】。</li><li>mouseenter 与 mouseleave 是一对事件，只有当鼠标经过当前元素时，事件会触发，鼠标经过子元素，mousenter 事件是不会触发的。</li></ol><h2 id="index-方法"><a href="#index-方法" class="headerlink" title="index 方法"></a>index 方法</h2><blockquote><p><code>index()</code>方法返回的是当前元素在所有兄弟元素里面的索引。</p></blockquote><pre class=" language-lang-html"><code class="language-lang-html"><ul>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li>  <li><a href="#">我是链接</a></li></ul></code></pre><p><strong>当碰到这种结构的时候，推荐给 li 注册事件，这样通过 index 方法才能获取到正确的索引值。</strong></p><h2 id="区分-jQuery-与-Javascript"><a href="#区分-jQuery-与-Javascript" class="headerlink" title="区分 jQuery 与 Javascript"></a>区分 jQuery 与 Javascript</h2><p>JavaScript 是一门编程语言，jQuery 仅仅是用 JavaScript 实现的一个 JavaScript 库，目的是简化我们的开发。</p><p><img src="/images/1.png" alt></p><h1 id="jQuery操作样式"><a href="#jQuery操作样式" class="headerlink" title="jQuery操作样式"></a>jQuery操作样式</h1><h2 id="css操作"><a href="#css操作" class="headerlink" title="css操作"></a>css操作</h2><blockquote><p>功能：设置或者修改样式，操作的是style属性。</p><p>操作单个样式</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name：需要设置的样式名称//value：对应的样式值css(name, value);//使用案例$("#one").css("background","gray");//将背景色修改为灰色</code></pre><blockquote><p>设置多个样式</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//参数是一个对象，对象中包含了需要设置的样式名和样式值css(obj);//使用案例$("#one").css(&#123;    "background":"gray",    "width":"400px",    "height":"200px"&#125;);</code></pre><blockquote><p>获取样式</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name:需要获取的样式名称css(name);//案例$("div").css("background-color");</code></pre><p>注意：获取样式操作只会返回第一个元素对应的样式值。</p><ol><li>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值</li><li>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</li></ol><h2 id="class操作"><a href="#class操作" class="headerlink" title="class操作"></a>class操作</h2><blockquote><p>添加样式类</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name：需要添加的样式类名，注意参数不要带点.addClass(name);//例子,给所有的div添加one的样式。$(“div”).addClass(“one”);</code></pre><blockquote><p>移除样式类</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name:需要移除的样式类名removeClass(“name”);//例子，移除div中one的样式类名$(“div”).removeClass(“one”);</code></pre><blockquote><p>判断是否有某个样式类</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name: 用于判断的样式类名，返回值为true falsehasClass(name)//例子，判断是否有one的样式类$(“div”).hasClass(“one”);</code></pre><blockquote><p>切换样式类</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。toggleClass(name);//例子$(“div”).toggleClass(“one”);</code></pre><h1 id="jQuery操作属性"><a href="#jQuery操作属性" class="headerlink" title="jQuery操作属性"></a>jQuery操作属性</h1><h2 id="attr操作"><a href="#attr操作" class="headerlink" title="attr操作"></a>attr操作</h2><blockquote><p>设置单个属性</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//第一个参数：需要设置的属性名//第二个参数：对应的属性值attr(name, value);//用法举例$(“img”).attr(“title”,”哎哟，不错哦”);$(“img”).attr(“alt”,“哎哟，不错哦”);</code></pre><blockquote><p>设置多个属性</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//参数是一个对象，包含了需要设置的属性名和属性值attr(obj)//用法举例$("img").attr(&#123;    title:"哎哟，不错哦",    alt:"哎哟，不错哦",    style:"opacity:.5"&#125;);</code></pre><blockquote><p>获取属性</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//传需要获取的属性名称，返回对应的属性值attr(name)//用法举例var oTitle = $("img").attr("title");alert(oTitle);</code></pre><blockquote><p>移除属性</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//参数：需要移除的属性名，removeAttr(name);//用法举例$("img").removeAttr("title");</code></pre><h2 id="prop操作"><a href="#prop操作" class="headerlink" title="prop操作"></a>prop操作</h2><blockquote><p>在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//设置属性$(“input:checked”).prop(“checked”,true);//获取属性$(“input:checked”).prop(“checked”);//返回true或者false</code></pre><h1 id="jQuery动画"><a href="#jQuery动画" class="headerlink" title="jQuery动画"></a>jQuery动画</h1><blockquote><p>jquery提供了三组基本动画，这些动画都是标准的、有规律的效果，jquery还提供了自定义动画的功能。【演示动画例子】</p></blockquote><h2 id="三组基本动画"><a href="#三组基本动画" class="headerlink" title="三组基本动画"></a>三组基本动画</h2><blockquote><p>显示(show)与隐藏(hide)是一组动画：<br>滑入(slideUp)与滑出(slideDown)与切换(slideToggle)，效果与卷帘门类似<br>淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle)</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">show([speed], [easing], [callback]);//speed(可选)：动画的执行时间     //1.如果不传，就没有动画效果。如果是slide和fade系列，会默认为normal     //2.毫秒值(比如1000),动画在1000毫秒执行完成(推荐)     //3.固定字符串，slow(200)、normal(400)、fast(600)，如果传其他字符串，则默认为normal。// easing(可选)： 动画效果，默认是swing，秋千，提供了一个linear 匀速的效果//callback(可选):执行完动画后执行的回调函数</code></pre><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><blockquote><p>animate: 自定义动画</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(selector).animate(&#123;params&#125;,[speed],[easing],[callback]);// &#123;params&#125;：要执行动画的CSS属性，带数字（必选）// speed：执行动画时长（可选）// easing: 执行效果，默认为swing（缓动）  可以是linear（匀速）// callback：动画执行完后立即执行的回调函数（可选）</code></pre><h2 id="动画队列与停止动画"><a href="#动画队列与停止动画" class="headerlink" title="动画队列与停止动画"></a>动画队列与停止动画</h2><blockquote><p>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行。</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//stop方法：停止动画效果stop(clearQueue, jumpToEnd);//第一个参数：是否清除队列//第二个参数：是否跳转到最终效果</code></pre><h1 id="jQuery节点操作"><a href="#jQuery节点操作" class="headerlink" title="jQuery节点操作"></a>jQuery节点操作</h1><h2 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">//$(htmlStr)//htmlStr：html格式的字符串$("<span>这是一个span元素</span>");</code></pre><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">// append  appendTo   都是添加到元素内部的最后面// prepend prependTo  都是添加到元素内部的最前面// before          添加到元素前面，做兄弟// after        添加到元素后面，做兄弟</code></pre><h2 id="清空节点与删除节点"><a href="#清空节点与删除节点" class="headerlink" title="清空节点与删除节点"></a>清空节点与删除节点</h2><blockquote><p>empty：清空指定节点的所有元素，自身保留(清理门户)</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(“div”).empty();//清空div的所有内容</code></pre><blockquote><p>remove：相比于empty，自身也删除（自杀）</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(“div”).remove();</code></pre><h2 id="克隆节点"><a href="#克隆节点" class="headerlink" title="克隆节点"></a>克隆节点</h2><blockquote><p>作用：复制匹配的元素</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 复制$(selector)所匹配到的元素（深度复制）// cloneNode(true)// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。$(selector).clone();</code></pre><h1 id="jQuery-特殊属性操作"><a href="#jQuery-特殊属性操作" class="headerlink" title="jQuery 特殊属性操作"></a>jQuery 特殊属性操作</h1><h2 id="val-方法"><a href="#val-方法" class="headerlink" title="val 方法"></a>val 方法</h2><blockquote><p>val 方法用于设置和获取表单元素的值，例如 input、textarea 的值</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//设置值$("#name").val(“张三”);//获取值$("#name").val();</code></pre><h2 id="html-方法与-text-方法"><a href="#html-方法与-text-方法" class="headerlink" title="html 方法与 text 方法"></a>html 方法与 text 方法</h2><blockquote><p>html 方法相当于 innerHTML text 方法相当于 innerText</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//设置内容$("div").html("<span>这是一段内容</span>");//获取内容$("div").html();//设置内容$("div").text("<span>这是一段内容</span>");//获取内容$("div").text();</code></pre><p>区别：html 方法会识别 html 标签，text 方法会将内容直接当成字符串，并不会识别 html 标签。</p><h2 id="width-方法与-height-方法"><a href="#width-方法与-height-方法" class="headerlink" title="width 方法与 height 方法"></a>width 方法与 height 方法</h2><blockquote><p>设置或者获取高度</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//带参数表示设置高度$(“img”).height(200);//不带参数获取高度$(“img”).height();</code></pre><p>获取网页的可视区宽高</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//获取可视区宽度$(window).width();//获取可视区高度$(window).height();</code></pre><h2 id="scrollTop-与-scrollLeft"><a href="#scrollTop-与-scrollLeft" class="headerlink" title="scrollTop 与 scrollLeft"></a>scrollTop 与 scrollLeft</h2><blockquote><p>设置或者获取垂直滚动条的位置</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">//获取页面被卷曲的高度$(window).scrollTop();//获取页面被卷曲的宽度$(window).scrollLeft();</code></pre><h1 id="jQuery-事件机制"><a href="#jQuery-事件机制" class="headerlink" title="jQuery 事件机制"></a>jQuery 事件机制</h1><blockquote><p>JavaScript 中已经学习过了事件，但是 jQuery 对 JavaScript 事件进行了封装，增加并扩展了事件处理机制。jQuery 不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</p></blockquote><h2 id="jQuery-事件"><a href="#jQuery-事件" class="headerlink" title="jQuery 事件"></a>jQuery 事件</h2><blockquote><p>简单事件注册</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">click(handler)            单击事件mouseenter(handler)        鼠标进入事件mouseleave(handler)        鼠标离开事件</code></pre><p>缺点：不能同时注册多个事件 &amp;&amp; 不支持动态绑定</p><h2 id="on-注册事件-重点"><a href="#on-注册事件-重点" class="headerlink" title="on 注册事件(重点)"></a>on 注册事件(重点)</h2><blockquote><p>jQuery1.7 之后，jQuery 用 on 来注册事件， 最现代的方式，强烈建议使用。</p></blockquote><p>on 注册简单事件</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 表示给$(selector)绑定事件，并且由自己触发，不支持动态绑定。$(selector).on("click", function () &#123;&#125;);</code></pre><p>on 注册委托事件</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 表示给$(selector)绑定代理事件，当必须是它的内部元素span才能触发这个事件，支持动态绑定$(selector).on( "click",“span”, function() &#123;&#125;);</code></pre><p>on 注册事件的语法：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 第一个参数：events，绑定事件的名称可以是由空格分隔的多个事件（标准事件或者自定义事件）// 第二个参数：selector, 执行事件的后代元素（可选），如果没有后代元素，那么事件将有自己执行。// 第三个参数：data，传递给处理函数的数据，事件触发的时候通过event.data来使用（不常使用）// 第四个参数：handler，事件处理函数$(selector).on(events[,selector][,data],handler);</code></pre><h2 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h2><blockquote><p>off 方式（推荐）</p></blockquote><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 解绑匹配元素的所有事件$(selector).off();// 解绑匹配元素的所有click事件$(selector).off("click");</code></pre><h2 id="触发事件"><a href="#触发事件" class="headerlink" title="触发事件"></a>触发事件</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">$(selector).click(); //触发 click事件$(selector).trigger("click");</code></pre><h2 id="jQuery-事件对象"><a href="#jQuery-事件对象" class="headerlink" title="jQuery 事件对象"></a>jQuery 事件对象</h2><p>jQuery 事件对象其实就是 js 事件对象的一个封装，处理了兼容性。</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">//screenX和screenY    对应屏幕最左上角的值//clientX和clientY    距离页面左上角的位置（忽视滚动条）//pageX和pageY    距离页面最顶部的左上角的位置（会计算滚动条的距离）//event.keyCode    按下的键盘代码//event.data    存储绑定事件时传递的附加数据//event.stopPropagation()    阻止事件冒泡行为//event.preventDefault()    阻止浏览器默认行为//return false 既能阻止事件冒泡，又能阻止浏览器默认行为。</code></pre><h1 id="jQuery补充知识点"><a href="#jQuery补充知识点" class="headerlink" title="jQuery补充知识点"></a>jQuery补充知识点</h1><h2 id="隐式迭代"><a href="#隐式迭代" class="headerlink" title="隐式迭代"></a>隐式迭代</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote><p>隐式迭代：jQuery在设置属性时会自动的遍历，因此我们不需要再遍历</p></blockquote><ol><li>jQuery在执行设置性操作时，会给所有的元素都设置上相同的值。</li><li>jQuery在执行获取性操作时，只会返回第一个元素对应的值。</li><li>如果想要给每一个元素都设置不同的值，需要手动进行遍历jQuery对象。</li></ol><h3 id="each方法"><a href="#each方法" class="headerlink" title="each方法"></a>each方法</h3><blockquote><p>遍历jQuery对象集合，为每个匹配的元素执行一个函数</p></blockquote><p>语法：</p><pre class=" language-lang-javascript"><code class="language-lang-javascript">// 参数一表示当前元素在所有匹配元素中的索引号// 参数二表示当前元素, 在function中this也表示当前元素。$(selector).each(function(index,element)&#123;&#125;);</code></pre><h2 id="链式编程"><a href="#链式编程" class="headerlink" title="链式编程"></a>链式编程</h2><blockquote><p>链式编程的原理：设置性操作会返回一个jQuery对象，因此可以继续调用jQuery的方法。</p></blockquote><ol><li>设置操作的时候，可以使用链式编程。</li><li>获取操作的时候，无法使用链式编程。</li></ol><pre class=" language-lang-javascript"><code class="language-lang-javascript">end(); // 上一次返回的jq对象</code></pre><pre class=" language-lang-javascript"><code class="language-lang-javascript">prevAll();//获取前面所有的兄弟元素nextAll();//获取后面所有的兄弟元素siblings();//获取所有的兄弟元素prev();//获取前一个兄弟next();//获取后一个兄弟。</code></pre><h1 id="jQuery插件"><a href="#jQuery插件" class="headerlink" title="jQuery插件"></a>jQuery插件</h1><blockquote><p>插件：jquery不可能包含所有的功能，我们可以通过插件扩展jquery的功能。</p></blockquote><p>jQuery有着丰富的插件，使用这些插件能给jQuery提供一些额外的功能。</p><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><pre class=" language-lang-javascript"><code class="language-lang-javascript">1. 引入jQuery文件2. 引入插件（如果有用到css的话，需要引入css）3. 使用插件</code></pre><p>常用插件的使用</p><ul><li>jquery.color.js的使用<ul><li><a href="https://github.com/jquery/jquery-color">https://github.com/jquery/jquery-color</a></li></ul></li></ul><ul><li>jquery.lazyload.js的使用<ul><li><a href="https://github.com/tuupola/jquery_lazyload">https://github.com/tuupola/jquery_lazyload</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> js库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
