<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue的状态管理工具之vuex</title>
      <link href="vuex/"/>
      <url>vuex/</url>
      
        <content type="html"><![CDATA[<h1 id="vuex-概述"><a href="#vuex-概述" class="headerlink" title="vuex 概述"></a>vuex 概述</h1><p>目标：</p><ul><li>了解vuex的应用场景  (在哪用)</li><li>掌握vuex的基本使用  (怎么用)</li></ul><p><strong>vuex 是一个 vue 的状态管理工具,  状态即数据</strong></p><h2 id="回顾-组件之间共享状态-组件通信方案"><a href="#回顾-组件之间共享状态-组件通信方案" class="headerlink" title="回顾-组件之间共享状态 (组件通信方案)"></a>回顾-组件之间共享状态 (组件通信方案)</h2><p>默认组件的数据, 是独立的, 每个组件有着自己的状态(数据)</p><blockquote><p> 状态 === 数据</p></blockquote><p><img src="/asset/image-20201029060003070.png" alt="image-20201029060003070"></p><p>组件之间共享状态的两种典型方式：</p><ul><li><p>父子之间 : props + $emit</p><p>父传子：props属性绑定</p><pre><code>&lt;son1 msg=&quot;msg&quot;&gt;&lt;/son1&gt;</code></pre><p>子传父：$emit事件绑定</p><pre><code>&lt;div&gt;    &lt;button @click=&quot;$emit(&#39;event-name&#39;)&quot;&gt;通知父组件&lt;/button&gt;&lt;/div&gt;</code></pre></li><li><p>非父子之间：EventBus 事件总线</p><ul><li><p>创建一个都能访问到的事件总线</p></li><li><p>在 A 组件中, bus.$emit</p></li><li>在 B 组件中, bus.$on</li></ul></li></ul><p>如果某个状态需要在很多个组件来使用，或者要实现多个组件共同维护一份数据又应该怎么做呢 ？</p><p>这里就要引入Vuex了。</p><h2 id="vuex基本概念"><a href="#vuex基本概念" class="headerlink" title="vuex基本概念"></a>vuex基本概念</h2><p><a href="https://vuex.vuejs.org/zh/guide/">中文文档</a></p><p>vuex是vue的状态管理工具，<strong>状态即数据</strong>。 状态管理就是集中管理vue中通用的一些数据</p><p>注意：</p><ul><li>不是所有的场景都适用于vuex，只有在必要的时候才使用vuex</li><li>使用了vuex之后，会附加更多的框架中的概念进来，增加了项目的复杂度</li></ul><p>Vuex就像近视眼镜, 你自然会知道什么时候需要用它~</p><h2 id="vuex的优点-方便的解决多组件的共享状态"><a href="#vuex的优点-方便的解决多组件的共享状态" class="headerlink" title="vuex的优点: 方便的解决多组件的共享状态"></a>vuex的优点: 方便的解决多组件的共享状态</h2><p> vuex的作用是解决多组件状态共享的问题。</p><ul><li>它是独立于组件而单独存在的，所有的组件都可以把它当作一座桥梁来进行通讯。</li><li><p>与事件总线（EventBus）相比，它具备额外的特点：</p><ul><li><strong>响应式</strong></li><li>操作更简洁</li></ul><p>代码量非常少, 但是需要熟悉</p></li></ul><p><img src="/asset/image-20201029061043482.png" alt="image-20201029061043482"></p><h2 id="什么数据适合存到vuex中"><a href="#什么数据适合存到vuex中" class="headerlink" title="什么数据适合存到vuex中"></a>什么数据适合存到vuex中</h2><p>一般情况下，只有  <strong>多个组件均需要共享的数据</strong> ，才有必要存储在vuex中，</p><p>对于某个组件中的私有数据，依旧存储在组件自身的data中。</p><p>例如：</p><ul><li>对于所有组件而言，当前登陆的用户信息是需要在全体组件之间共享的，则它可以放在vuex中</li><li>对于文章详情页组件来说，当前的用户浏览的文章列表数据则应该属于这个组件的私有数据，应该要放在这个组件data中。</li></ul><h2 id="概述小结"><a href="#概述小结" class="headerlink" title="概述小结:"></a>概述小结:</h2><ol><li>vuex解决什么问题?   可以解决多组件共享状态的问题</li><li>什么样的数据, 适合存放到vuex?  多组件都需要用到的数据, 才往vuex中存</li></ol><p>vuex是响应式的, 只要vuex中的数据改了, 那么所有用到这个数据的地方, 都会更新!!!</p><h1 id="vuex入门"><a href="#vuex入门" class="headerlink" title="vuex入门"></a>vuex入门</h1><h2 id="初始化一个vuex项目"><a href="#初始化一个vuex项目" class="headerlink" title="初始化一个vuex项目"></a>初始化一个vuex项目</h2><ul><li>初始化命令</li></ul><pre><code>vue create 02-vuex</code></pre><ul><li>vue项目如何配置自动打开浏览器</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 1. 在项目的根目录，创建vue.config.js配置文件/*   我们可以通过vue.config.js文件覆盖vue-cli中webpack的配置文件*/module.exports = &#123;  // 导出配置  devServer: &#123;    open: true,    port: 3000  &#125;&#125;</code></pre><h2 id="需求-多组件共享数据"><a href="#需求-多组件共享数据" class="headerlink" title="需求: 多组件共享数据"></a>需求: 多组件共享数据</h2><p>对于如下三个组件（一个父组件，两个子组件）</p><p><img src="/asset/image-20201029080515105.png" alt="image-20201029080515105"></p><p>效果是三个组件共享一份数据:</p><ul><li>任意一个组件都可以修改数据</li><li>三个组件的数据是同步的</li></ul><p>1 创建项目</p><pre><code>vue create 03-vuex-demo</code></pre><p>2 创建三个组件, 目录如下</p><pre><code>|-components|--add-item.vue|--sub-item.vue|-App.vue</code></pre><p>3 源代码如下</p><p><code>App.vue</code></p><p>在入口组件中引入add-item和sub-item这两个子组件</p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div id="app">    <h1>根组件</h1>    <input type="text">    <add-item></add-item>    <hr>    <sub-item></sub-item>  </div></template><script>import AddItem from './components/add-item.vue'import SubItem from './components/sub-item.vue'export default &#123;  name: 'app',  data: function () &#123;    return &#123;    &#125;  &#125;,  components: &#123;    AddItem,    SubItem  &#125;&#125;</script><style>#app &#123;  width: 300px;  margin: 20px auto;  border: 3px solid #ccc;  border-radius: 3px;  padding: 10px;&#125;</style></code></pre><p><code>main.js</code></p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'Vue.config.productionTip = falsenew Vue(&#123;  render: h => h(App)&#125;).$mount('#app')</code></pre><p><code>sub-item.vue</code></p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div class="box">    <h2>子组件 sub</h2>    从父组件中获取的值: <label></label>    <br>    <button>值-1</button>  </div></template><script>export default &#123;  name: 'SubItem'&#125;</script><style lang="css" scoped>.box&#123;  border: 3px solid #ccc;  width: 200px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;</style></code></pre><p><code>add-item.vue</code></p><pre class=" language-lang-html"><code class="language-lang-html"><template>  <div class="box">    <h2>子组件 add</h2>    从父组件中获取的值:<label></label>    <br />    <button>值+1</button>  </div></template><script>export default &#123;  name: 'AddItem'&#125;</script><style lang="css" scoped>.box &#123;  border: 3px solid #ccc;  width: 200px;  padding: 10px;  margin: 20px;&#125;h2 &#123;  margin-top: 10px;&#125;</style></code></pre><h2 id="vuex-的使用-创建仓库"><a href="#vuex-的使用-创建仓库" class="headerlink" title="vuex 的使用 - 创建仓库"></a>vuex 的使用 - 创建仓库</h2><p>1 安装 vuex, 与vue-router类似，vuex是一个独立存在的插件，如果脚手架初始化没有选 vuex，就需要额外安装。</p><pre><code>yarn add vuex</code></pre><p>2 新建 <code>store/index.js</code> 专门存放 vuex</p><p>​    为了维护项目目录的整洁，在src目录下新建一个store目录其下放置一个index.js文件。 (和 <code>router/index.js</code> 类似)</p><p>3 创建仓库 <code>store/index.js</code> </p><pre class=" language-lang-jsx"><code class="language-lang-jsx">// 导入 vueimport Vue from 'vue'// 导入 vueximport Vuex from 'vuex'// vuex也是vue的插件, 需要use一下, 进行插件的安装初始化Vue.use(Vuex)// 创建仓库 storeconst store = new Vuex.Store()// 导出仓库export default store</code></pre><p>4 在 main.js 中导入挂载到 Vue 实例上</p><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'import store from './store'Vue.config.productionTip = falsenew Vue(&#123;  render: h => h(App),  store&#125;).$mount('#app')</code></pre><p>此刻起, 就成功创建了一个空仓库!!</p><h2 id="核心概念-state-状态"><a href="#核心概念-state-状态" class="headerlink" title="核心概念 - state 状态"></a>核心概念 - state 状态</h2><p>State提供唯一的公共数据源，所有共享的数据都要统一放到Store中的State中存储。</p><p>打开项目中的store.js文件，在state对象中可以添加我们要共享的数据。</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">// 创建仓库 storeconst store = new Vuex.Store(&#123;  // state 状态, 即数据, 类似于vue组件中的data,  // 区别在于 data 是组件自己的数据, 而 state 中的数据整个vue项目的组件都能访问到  state: &#123;    count: 101  &#125;&#125;)</code></pre><p>问题: 如何在组件中获取count?</p><ol><li>插值表达式 =》  </li><li>mapState 映射计算属性 =》  </li></ol><p><strong>1 原始形式- 插值表达式</strong></p><p><strong><code>App.vue</code></strong></p><p>组件中可以使用  <strong>this.$store</strong> 获取到vuex中的store对象实例，可通过<strong>state</strong>属性属性获取<strong>count</strong>， 如下</p><pre class=" language-lang-vue"><code class="language-lang-vue"><h1>state的数据 - &#123;&#123; $store.state.count &#125;&#125;</h1></code></pre><p><strong>计算属性</strong> - 将state属性定义在计算属性中 <a href="https://vuex.vuejs.org/zh/guide/state.html">https://vuex.vuejs.org/zh/guide/state.html</a></p><pre class=" language-lang-js"><code class="language-lang-js">// 把state中数据，定义在组件内的计算属性中  computed: &#123;    count () &#123;      return this.$store.state.count    &#125;  &#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"><h1>state的数据 - &#123;&#123; count &#125;&#125;</h1></code></pre><p>但是每次, 都这样一个个的提供计算属性, 太麻烦了, 所以我们需要辅助函数 mapState 帮我们简化语法</p><p><strong>2 辅助函数  - mapState</strong></p><blockquote><p>mapState是辅助函数，帮助我们把store中的数据映射到 组件的计算属性中, 它属于一种方便的用法</p></blockquote><p>用法 ： </p><p>第一步：导入mapState (mapState是vuex中的一个函数)</p><pre class=" language-lang-js"><code class="language-lang-js">import &#123; mapState &#125; from 'vuex'</code></pre><p>第二步：采用数组形式引入state属性</p><pre class=" language-lang-js"><code class="language-lang-js">mapState(['count'])</code></pre><blockquote><p>上面代码的最终得到的是 <strong>类似于</strong></p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">count () &#123;    return this.$store.state.count&#125;</code></pre><p>第三步：利用<strong>展开运算符</strong>将导出的状态映射给计算属性</p><pre class=" language-lang-js"><code class="language-lang-js">  computed: &#123;    ...mapState(['count'])  &#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"> <div> state的数据：&#123;&#123; count &#125;&#125;</div></code></pre><h2 id="核心概念-mutations"><a href="#核心概念-mutations" class="headerlink" title="核心概念 - mutations"></a>核心概念 - mutations</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>通过 <code>strict: true</code> 可以开启严格模式</p><blockquote><p><strong>state数据的修改只能通过mutations，并且mutations必须是同步的</strong></p></blockquote><p><strong>定义mutations</strong></p><pre class=" language-lang-js"><code class="language-lang-js">const store  = new Vuex.Store(&#123;  state: &#123;    count: 0  &#125;,  // 定义mutations  mutations: &#123;  &#125;&#125;)</code></pre><p><strong>格式说明</strong></p><p>mutations是一个对象，对象中存放修改state的方法</p><pre class=" language-lang-js"><code class="language-lang-js">mutations: &#123;    // 方法里参数 第一个参数是当前store的state属性    // payload 载荷 运输参数 调用mutaiions的时候 可以传递参数 传递载荷    addCount (state) &#123;      state.count += 1    &#125;  &#125;,</code></pre><p>组件中提交 mutations</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">this.$store.commit('addCount')</code></pre><p><strong>解决问题: 两个子组件, 添加操作 add,  addN 实现</strong></p><h3 id="带参数的-mutation"><a href="#带参数的-mutation" class="headerlink" title="带参数的 mutation"></a>带参数的 mutation</h3><p>需求: 父组件也希望能改到数据</p><p>提交 mutation 是可以传递参数的  <code>this.$store.commit(&#39;xxx&#39;,  参数)</code></p><p>1 提供mutation函数</p><pre class=" language-lang-js"><code class="language-lang-js">mutations: &#123;  ...  inputCount (state, count) &#123;    state.count = count  &#125;&#125;,</code></pre><p>2 注册事件</p><pre class=" language-lang-jsx"><code class="language-lang-jsx"><input type="text" :value="count" @input="handleInput"></code></pre><p>3 提交mutation</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">handleInput (e) &#123;  this.$store.commit('inputCount', +e.target.value)&#125;</code></pre><p><strong>小tips: 提交的参数只能是一个, 如果有多个参数要传, 可以传递一个对象</strong></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">this.$store.commit('inputCount', &#123;  count: e.target.value&#125;)</code></pre><p><strong>解决问题:  addN 的实现</strong></p><h3 id="辅助函数-mapMutations"><a href="#辅助函数-mapMutations" class="headerlink" title="辅助函数 - mapMutations"></a><strong>辅助函数</strong> - mapMutations</h3><blockquote><p>mapMutations和mapState很像，它把位于mutations中的方法提取了出来，我们可以将它导入</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">import  &#123; mapMutations &#125; from 'vuex'methods: &#123;    ...mapMutations(['addCount'])&#125;</code></pre><blockquote><p>上面代码的含义是将mutations的方法导入了methods中，等价于</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">methods: &#123;      // commit(方法名, 载荷参数)      addCount () &#123;          this.$store.commit('addCount')      &#125; &#125;</code></pre><p>此时，就可以直接通过this.addCount调用了</p><pre class=" language-lang-jsx"><code class="language-lang-jsx"><button @click="addCount()">值+1</button></code></pre><p>但是请注意： Vuex中mutations中要求不能写异步代码，如果有异步的ajax请求，应该放置在actions中</p><h2 id="核心概念-actions"><a href="#核心概念-actions" class="headerlink" title="核心概念-actions"></a>核心概念-actions</h2><blockquote><p>state是存放数据的，mutations是同步更新数据 (便于监测数据的变化, 更新视图等, 方便于调试工具查看变化)，</p><p>actions则负责进行异步操作</p></blockquote><p><strong>需求: 一秒钟之后, 要给一个数 去修改state</strong></p><p><img src="/asset/image-20201029074727223.png" alt="image-20201029074727223"></p><p><strong>定义actions</strong></p><pre class=" language-lang-js"><code class="language-lang-js">actions: &#123;  setAsyncCount (context, num) &#123;    // 一秒后, 给一个数, 去修改 num    setTimeout(() => &#123;      context.commit('inputCount', num)    &#125;, 1000)  &#125;&#125;,</code></pre><p><strong>原始调用</strong> - $store (支持传参)</p><pre class=" language-lang-js"><code class="language-lang-js">setAsyncCount () &#123;  this.$store.dispatch('setAsyncCount', 200)&#125;</code></pre><p><strong>辅助函数</strong> -mapActions</p><blockquote><p>actions也有辅助函数，可以将action导入到组件中</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">import &#123; mapActions &#125; from 'vuex'methods: &#123;    ...mapActions(['setAsyncCount'])&#125;</code></pre><p>直接通过 this.方法 就可以调用</p><pre class=" language-lang-vue"><code class="language-lang-vue"><button @click="setAsyncCount(200)">+异步</button></code></pre><h2 id="核心概念-getters"><a href="#核心概念-getters" class="headerlink" title="核心概念-getters"></a>核心概念-getters</h2><blockquote><p>除了state之外，有时我们还需要从state中派生出一些状态，这些状态是依赖state的，此时会用到getters</p></blockquote><p>例如，state中定义了list，为1-10的数组，</p><pre class=" language-lang-js"><code class="language-lang-js">state: &#123;    list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#125;</code></pre><p>组件中，需要显示所有大于5的数据，正常的方式，是需要list在组件中进行再一步的处理，但是getters可以帮助我们实现它</p><p><strong>定义getters</strong></p><pre class=" language-lang-js"><code class="language-lang-js">  getters: &#123;    // getters函数的第一个参数是 state    // 必须要有返回值     filterList:  state =>  state.list.filter(item => item > 5)  &#125;</code></pre><p>使用getters</p><p><strong>原始方式</strong> -$store</p><pre class=" language-lang-vue"><code class="language-lang-vue"><div>&#123;&#123; $store.getters.filterList &#125;&#125;</div></code></pre><p><strong>辅助函数</strong> - mapGetters</p><pre class=" language-lang-js"><code class="language-lang-js">computed: &#123;    ...mapGetters(['filterList'])&#125;</code></pre><pre class=" language-lang-vue"><code class="language-lang-vue"> <div>&#123;&#123; filterList &#125;&#125;</div></code></pre><h2 id="核心概念-模块-module-进阶拓展"><a href="#核心概念-模块-module-进阶拓展" class="headerlink" title="核心概念 - 模块 module (进阶拓展)"></a>核心概念 - 模块 module (进阶拓展)</h2><blockquote><p><strong>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</strong></p></blockquote><p>这句话的意思是，如果把所有的状态都放在state中，当项目变得越来越大的时候，Vuex会变得越来越难以维护</p><p>由此，又有了Vuex的模块化</p><p><img src="/asset/image-20201029155607101.png" alt="image-20201029155607101"></p><h3 id="模块定义-准备-state"><a href="#模块定义-准备-state" class="headerlink" title="模块定义 - 准备 state"></a><strong>模块定义</strong> - 准备 state</h3><p>定义两个模块   <strong>user</strong> 和  <strong>setting</strong></p><p>user中管理用户的信息状态  userInfo  <code>modules/user.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  userInfo: &#123;    name: 'zs',    age: 18  &#125;&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>setting中管理项目应用的名称 title, desc  <code>modules/setting.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  title: '这是大标题',  desc: '描述真呀真不错'&#125;const mutations = &#123;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  state,  mutations,  actions,  getters&#125;</code></pre><p>使用模块中的数据,  可以直接通过模块名访问 <code>$store.state.模块名.xxx</code>  =&gt;  <code>$store.state.setting.title</code></p><h3 id="命名空间-namespaced"><a href="#命名空间-namespaced" class="headerlink" title="命名空间 namespaced"></a>命名空间 namespaced</h3><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局命名空间</strong>的</p><p>这句话的意思是 刚才的user模块还是setting模块，它的 action、mutation 和 getter 其实并没有区分，都可以直接通过全局的方式调用, 如下图所示:</p><p><img src="/asset/image-20201029163627229.png" alt="image-20201029163627229"></p><p>但是，如果我们想保证内部模块的高封闭性，我们可以采用namespaced来进行设置</p><p><code>modules/user.js</code></p><pre class=" language-lang-jsx"><code class="language-lang-jsx">const state = &#123;  userInfo: &#123;    name: 'zs',    age: 18  &#125;,  myMsg: '我的数据'&#125;const mutations = &#123;  updateMsg (state, msg) &#123;    state.myMsg = msg  &#125;&#125;const actions = &#123;&#125;const getters = &#123;&#125;export default &#123;  namespaced: true,  state,  mutations,  actions,  getters&#125;</code></pre><p>提交模块中的mutation</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">全局的:   this.$store.commit('mutation函数名', 参数)模块中的: this.$store.commit('模块名/mutation函数名', 参数)</code></pre><p>namespaced: true 后, 要添加映射, 可以加上模块名, 找对应模块的 state/mutations/actions/getters</p><pre class=" language-lang-jsx"><code class="language-lang-jsx">computed: &#123;  // 全局的  ...mapState(['count']),  // 模块中的  ...mapState('user', ['myMsg']),&#125;,methods: &#123;  // 全局的  ...mapMutations(['addCount'])  // 模块中的  ...mapMutations('user', ['updateMsg'])&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> vue全家桶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue如何给各个组件设置title</title>
      <link href="vue-ru-he-gei-ge-ge-zu-jian-she-zhi-title/"/>
      <url>vue-ru-he-gei-ge-ge-zu-jian-she-zhi-title/</url>
      
        <content type="html"><![CDATA[<h3 id="vue如何给各个组件设置头部"><a href="#vue如何给各个组件设置头部" class="headerlink" title="vue如何给各个组件设置头部"></a>vue如何给各个组件设置头部</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><ol><li><p><strong>首先安装依赖</strong></p><pre><code>npm install vue-wechat-title --save</code></pre></li><li><p><strong>在Vue.use里面使用</strong></p><pre class=" language-lang-js"><code class="language-lang-js">//在main.js文件中配置import vueWeChatTitle from 'vue-wechat-title'Vue.use(vueWeChatTitle)//引入模块 import Entrance from 'vue-wechat-title'//在router的index.js文件中配置&#123;    path: '/',    //路由名称    name: 'Entrance',    //Entrance 引入模块名称    component: Entrance,    meta: &#123;        //声明title        title: '首页入口'        &#125;&#125;</code></pre></li><li><p><strong>调用</strong></p><pre class=" language-lang-js"><code class="language-lang-js">//调用 在router-view视图中添加修改title的指令<router-view v-wechat-title="$route.meta.title" /></code></pre></li></ol><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><ol><li><p><strong>首先安装依赖</strong></p><pre><code>npm install vue-wechat-title --save</code></pre></li><li><p><strong>配置 main.js</strong></p><pre><code>//设置titleimport vueWeChatTitle from &#39;vue-wechat-title&#39;Vue.use(vueWeChatTitle)router.beforeEach(to, form, next) =&gt; &#123;    //路由发生变化时，修改页面title    if （to.meta.title) &#123;        document.title = to.meta.title    &#125;    next()&#125;</code></pre></li></ol><ol><li><p><strong>在你需要改变的页面 第一个div 上加上v-wechat-title=”this.title”, title 是下面再 data 里面定义的数据.</strong></p><pre><code>&lt;div v-wechat-title=&quot;this.title&quot;&gt;&lt;/div&gt;</code></pre></li><li><p>动态的改变title</p><pre class=" language-lang-js"><code class="language-lang-js">export default &#123;    data()&#123;        return &#123;            title: '你好啊'        &#125;    &#125;,    created()&#123;        //动态修改 使用方法写获取数据的方法 获取完成之后把文章的标题给title        this.title= 'sss'    &#125;&#125;</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置指南</title>
      <link href="webpack-pei-zhi-zhi-nan/"/>
      <url>webpack-pei-zhi-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="webpack概述"><a href="#webpack概述" class="headerlink" title="webpack概述"></a>webpack概述</h2><blockquote><p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler</em> )</p></blockquote><p><a href="https://www.webpackjs.com/">webpack中文网</a></p><p><a href="https://webpack.js.org/">webpack官网</a></p><h2 id="webpack做了什么"><a href="#webpack做了什么" class="headerlink" title="webpack做了什么"></a>webpack做了什么</h2><ul><li>语法转换<ul><li>less/sass转换成css</li><li>ES6转换成ES5</li><li>typescript转换成js</li></ul></li><li>html/css/js代码的压缩与合并（打包）</li><li>webpack可以在开发期间提供一个开发环境<ul><li>自动开启浏览器</li><li>自动监视文件变化</li><li>自动刷新浏览器</li></ul></li><li>项目一般都需要经过webpack打包之后才上线。</li></ul><h2 id="webpack模块说明"><a href="#webpack模块说明" class="headerlink" title="webpack模块说明"></a>webpack模块说明</h2><p>webpack会把所有的资源都当成模块</p><ul><li>css</li><li>js</li><li>图片</li><li>字体图标</li></ul><p>webpack给前端开发提供了模块化的开发环境</p><ul><li>对于js文件，webpack中支持AMD、CMD、commonJS、ES6模块化等语法</li><li>有了webpack，我们可以在前端代码中使用任意的模块化语法</li><li>可以在浏览器中使用nodejs的模块化语法<code>const $ = require(&#39;jquery&#39;)</code></li></ul><h2 id="webpack基本使用"><a href="#webpack基本使用" class="headerlink" title="webpack基本使用"></a>webpack基本使用</h2><ul><li>创建一个文件夹<code>webpack-demo</code></li><li>初始化项目 生成<code>package.json</code></li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn init -y</code></pre><ul><li>安装webpack的依赖包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add webpack webpack-cli -D</code></pre><ul><li>新建文件<code>src</code>和<code>dist</code>文件夹，，src用于提供源码，，dist用于存放打包后的文件</li><li><p>在src下新建了<code>index.js</code>文件，目的：对<code>src/index.js</code>文件进行打包</p></li><li><p>在package.json文件配置了打包的脚本</p></li></ul><pre class=" language-lang-js"><code class="language-lang-js">  "scripts": &#123;    "build": "webpack --config webpack.config.js"  &#125;</code></pre><ul><li>在项目的根目录，创建一个文件<code>webpack.config.js</code></li><li>执行打包命令</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn build</code></pre><h2 id="配置webpack的打包入口"><a href="#配置webpack的打包入口" class="headerlink" title="配置webpack的打包入口"></a>配置webpack的打包入口</h2><ul><li>在<code>webpack.config.js</code>文件中</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 这是webpack的配置文件 // webpack是运行在node环境中，webpack可以执行任意的node代码，包括可以使用node中模块。module.exports = &#123;  // 默认： ./src/index.js  entry: './src/app.js'&#125;</code></pre><h2 id="配置webpack的打包出口"><a href="#配置webpack的打包出口" class="headerlink" title="配置webpack的打包出口"></a>配置webpack的打包出口</h2><blockquote><p>配置webpack最终打包的文件的出口</p></blockquote><pre class=" language-lang-js"><code class="language-lang-js">  // 配置webpack打包出口  output: &#123;    // path： 打包出口的目录,默认 dist, 必须指定绝对路径    path: path.join(__dirname, 'lib'),    // filename: 打包出口的文件名字  默认 main.js    filename: 'bundle.js'  &#125;</code></pre><p>==如果要配置path，记得是绝对路径==</p><h2 id="配置webpack的打包模式"><a href="#配置webpack的打包模式" class="headerlink" title="配置webpack的打包模式"></a>配置webpack的打包模式</h2><pre class=" language-lang-js"><code class="language-lang-js">  // 打包模式  development|production  // development: 打包不会对进行压缩   打包快  // production: 打包会对代码进行压缩  上线  mode: 'development'</code></pre><h2 id="配置html-webpack-plugin插件"><a href="#配置html-webpack-plugin插件" class="headerlink" title="配置html-webpack-plugin插件"></a>配置html-webpack-plugin插件</h2><blockquote><p>html-webpack-plugin插件能够帮助我们自动在dist中生成一个html文件，并且会自动帮我们引入打包后的文件。</p></blockquote><ul><li>安装html-webpack-plugin插件</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add html-webpack-plugin -D</code></pre><ul><li>在<code>webpack.config.js</code>中配置</li></ul><pre class=" language-lang-js"><code class="language-lang-js">//1. 导入html-webpack-plugin插件const HtmlWebpackPlugin = require('html-webpack-plugin')// 2.配置webpack的插件，是一个数组plugins: [new HtmlWebpackPlugin(&#123;  // 生成html的模板  template: './src/index.html'&#125;)]</code></pre><h2 id="配置css-loader处理css文件"><a href="#配置css-loader处理css文件" class="headerlink" title="配置css-loader处理css文件"></a>配置css-loader处理css文件</h2><blockquote><p>webpack天生只能处理js文件，如果需要处理其他类型的文件，需要配置loader</p></blockquote><ul><li>安装依赖包</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add css-loader style-loader -D</code></pre><ul><li>配置loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">module: &#123;  rules: [    // 配置css-loader的规则    &#123;      // 匹配所有.css结尾的文件      test: /\.css$/,      // 使用css-loader 和 style-loader处理      use: ['style-loader', 'css-loader']    &#125;  ]&#125;</code></pre><p>==注意：loader加载顺序从右往左==</p><h2 id="配置less-loader处理less文件"><a href="#配置less-loader处理less文件" class="headerlink" title="配置less-loader处理less文件"></a>配置less-loader处理less文件</h2><ul><li>安装依赖包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add less-loader less -D</code></pre><ul><li>配置less-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// 配置less-loader的规则&#123;  // 匹配所有.less结尾的文件  test: /\.less$/,    // 使用css-loader 和 style-loader处理    use: ['style-loader', 'css-loader', 'less-loader']&#125;</code></pre><h2 id="配置file-loader处理图片"><a href="#配置file-loader处理图片" class="headerlink" title="配置file-loader处理图片"></a>配置file-loader处理图片</h2><ul><li>安装依赖包</li></ul><pre><code>yarn add file-loader -D</code></pre><ul><li>配置file-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">// file-loader配置&#123;  test: /\.(png|jpg|gif)$/,  use: 'file-loader'&#125;</code></pre><h2 id="配置url-loader处理图片"><a href="#配置url-loader处理图片" class="headerlink" title="配置url-loader处理图片"></a>配置url-loader处理图片</h2><ul><li>安装</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add url-loader file-loader -D</code></pre><ul><li>配置url-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.(png|jpg|gif)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;</code></pre><h2 id="配置字体图标和音视频"><a href="#配置字体图标和音视频" class="headerlink" title="配置字体图标和音视频"></a>配置字体图标和音视频</h2><pre class=" language-lang-js"><code class="language-lang-js">// 字体图标&#123;  test: /\.(eot|svg|ttf|woff)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;,&#123;  test: /\.(mp3|mp4|ogg)$/,  use: &#123;    loader: 'url-loader',    options: &#123;      limit: 20 * 1024    &#125;  &#125;&#125;</code></pre><h2 id="配置babel-loader"><a href="#配置babel-loader" class="headerlink" title="配置babel-loader"></a>配置babel-loader</h2><blockquote><p>babel可以把高版本的js语法转成低版本的js语法，保证运行的效果一样。能够兼容更多的浏览器。</p></blockquote><ul><li>安装依赖包</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add  babel-loader @babel/core @babel/preset-env -D</code></pre><ul><li>配置babel</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.m?js$/,  exclude: /(node_modules|bower_components)/,  use: &#123;    loader: 'babel-loader',    options: &#123;      presets: ['@babel/preset-env']    &#125;  &#125;&#125;</code></pre><h2 id="提取css到单独的文件中"><a href="#提取css到单独的文件中" class="headerlink" title="提取css到单独的文件中"></a>提取css到单独的文件中</h2><ul><li>安装插件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add mini-css-extract-plugin -D</code></pre><ul><li>配置插件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const MiniCssExtractPlugin = require('mini-css-extract-plugin');// 配置插件plugins: [  new MiniCssExtractPlugin(&#123;    // 指定生成的css文件名和路径    filename: './index.css',  &#125;)],</code></pre><ul><li>配置css和less的loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">&#123;  test: /\.css$/,  // css-loader只能够让webpack能够处理css文件  // style-loader： 能够把处理好的css代码添加到页面中  // MiniCssExtractPlugin.loader ; 把css提取到单独的css文件中  use: [MiniCssExtractPlugin.loader, 'css-loader']&#125;,&#123;  test: /\.less$/,  use: [MiniCssExtractPlugin.loader, 'css-loader', 'less-loader']&#125;,</code></pre><h2 id="webpack-dev-server的使用"><a href="#webpack-dev-server的使用" class="headerlink" title="webpack-dev-server的使用"></a>webpack-dev-server的使用</h2><blockquote><p>webpack-dev-server不是用来打包的，而是用于启动一个服务器，，，，，当我们代码发生了改变，webpack-dev-server会重新打包（内存）并且会刷新浏览器，实时看到效果</p><p>最新版本的webpack5还不支持，需要降级处理</p></blockquote><p><img src="/images/image-20201108181347423.png" alt="image-20201108181347423"></p><ul><li>安装包</li></ul><pre class=" language-lang-bash"><code class="language-lang-bash">yarn add webpack-dev-server -D## 注意：如果需要使用webpack-dev-server  就不能使用最新的webpack5版本， 应该使用webpack 4</code></pre><ul><li>配置一个脚本</li></ul><pre class=" language-lang-js"><code class="language-lang-js">  "scripts": &#123;    "build": "webpack --config webpack.config.js",    "serve": "webpack-dev-server --config webpack.config.js"  &#125;,</code></pre><ul><li>使用dev脚本</li></ul><pre><code>yarn serve</code></pre><ul><li>常见配置</li></ul><pre class=" language-lang-js"><code class="language-lang-js">  // devServer的配置  devServer: &#123;    // 自定义端口    port: 9090,    // 自动打开浏览器    open: true  &#125;</code></pre><h2 id="webpack处理vue文件"><a href="#webpack处理vue文件" class="headerlink" title="webpack处理vue文件"></a>webpack处理vue文件</h2><ul><li>新建了一个<code>App.vue</code>文件</li></ul><pre class=" language-lang-js"><code class="language-lang-js"><template>  <div class="app">我是根组件 ---&#123;&#123;msg&#125;&#125;  --<demo></demo> </div></template><script>export default &#123;  data() &#123;    return &#123;      msg: 'hello'    &#125;  &#125;,&#125;</script><style>.app &#123;  background-color: red;&#125;</style></code></pre><ul><li>在main.js中导入<code>App.vue</code>根组件，并且渲染成为根组件</li></ul><pre class=" language-lang-js"><code class="language-lang-js">import Vue from 'vue'import App from './App.vue'const vm = new Vue(&#123;  el: '##app',  // 把App组件渲染成根组件  render: c => c(App),  // 把app渲染成为根组件  // render: function(createElement) &#123;  //   return createElement(App)  // &#125;&#125;)</code></pre><ul><li><p>报错，因为webpack处理不了vue文件</p></li><li><p>安装依赖包</p></li></ul><pre class=" language-lang-js"><code class="language-lang-js">yarn add vue-loader@15.9.0 vue-template-compiler -D</code></pre><ul><li>在webpack.config.js中配置vue-loader</li></ul><pre class=" language-lang-js"><code class="language-lang-js">const VueLoaderPlugin = require('vue-loader/lib/plugin')  plugins: [    new VueLoaderPlugin()  ],    rules: [      &#123;        test: /\.vue$/,        loader: 'vue-loader'      &#125;    ]</code></pre><p>12</p>]]></content>
      
      
      <categories>
          
          <category> 打包工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
